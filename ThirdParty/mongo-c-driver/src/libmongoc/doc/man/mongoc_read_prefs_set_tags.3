.\" Man page generated from reStructuredText.
.
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.TH "MONGOC_READ_PREFS_SET_TAGS" "3" "Aug 31, 2022" "1.23.0" "libmongoc"
.SH NAME
mongoc_read_prefs_set_tags \- mongoc_read_prefs_set_tags()
.SH SYNOPSIS
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void
mongoc_read_prefs_set_tags (mongoc_read_prefs_t *read_prefs,
                            const bson_t *tags);
.ft P
.fi
.UNINDENT
.UNINDENT
.SH PARAMETERS
.INDENT 0.0
.IP \(bu 2
\fBread_prefs\fP: A \fI\%mongoc_read_prefs_t\fP\&.
.IP \(bu 2
\fBtags\fP: A \fI\%bson_t\fP\&.
.UNINDENT
.SH DESCRIPTION
.sp
Sets the tags to be used for the read preference. Only mongod instances matching these tags will be suitable for handling the request.
.SH EXAMPLES
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mongoc/mongoc.h>

static void
run_query_with_read_prefs_tags (mongoc_collection_t *collection)
{
   char *str;
   const bson_t *doc;
   bson_t filter = BSON_INITIALIZER;
   bson_error_t error;
   mongoc_cursor_t *cursor;
   mongoc_read_prefs_t *read_prefs;
   /*  Create a tagset representing
    *  [
    *    {\(dqdc\(dq: \(dqny\(dq, \(dqrack\(dq: \(dq1\(dq }, // Any node in rack1 in the ny datacenter
    *    {\(dqdc\(dq: \(dqny\(dq, \(dqrack\(dq: \(dq2\(dq }, // Any node in rack2 in the ny datacenter
    *    {\(dqdc\(dq: \(dqny\(dq },              // Any node in the ny datacenter
    *    {}                          // If all else fails, just any available node
    * ]
    */
   bson_t *tags = BCON_NEW (
      \(dq0\(dq, \(dq{\(dq, \(dqdc\(dq, BCON_UTF8(\(dqny\(dq), \(dqrack\(dq, BCON_UTF8(\(dq1\(dq), \(dq}\(dq,
      \(dq1\(dq, \(dq{\(dq, \(dqdc\(dq, BCON_UTF8(\(dqny\(dq), \(dqrack\(dq, BCON_UTF8(\(dq2\(dq), \(dq}\(dq,
      \(dq2\(dq, \(dq{\(dq, \(dqdc\(dq, BCON_UTF8(\(dqny\(dq), \(dq}\(dq,
      \(dq3\(dq, \(dq{\(dq, \(dq}\(dq
   );

   read_prefs = mongoc_read_prefs_new (MONGOC_READ_SECONDARY);
   mongoc_read_prefs_set_tags (read_prefs, tags);
   bson_destroy (tags);

   cursor =
      mongoc_collection_find_with_opts (collection, &filter, NULL, read_prefs);

   while (mongoc_cursor_next (cursor, &doc)) {
      str = bson_as_canonical_extended_json (doc, NULL);
      printf (\(dq%s\en\(dq, str);
      bson_free (str);
   }
   if (mongoc_cursor_error (cursor, &error)) {
      fprintf (stderr, \(dqCursor error: %s\en\(dq, error.message);
   }

   mongoc_cursor_destroy (cursor);
   mongoc_read_prefs_destroy (read_prefs);
   bson_destroy (doc);
}

int main (void)
{
   mongoc_client_t *client;
   mongoc_collection_t *collection;

   mongoc_init ();

   client =
      mongoc_client_new (\(dqmongodb://localhost/?appname=rp_tags&replicaSet=foo\(dq);
   mongoc_client_set_error_api (client, 2);
   collection = mongoc_client_get_collection (client, \(dqdbname\(dq, \(dqcollname\(dq);
   run_query_with_read_prefs_tags (collection);

   mongoc_collection_destroy (collection);
   mongoc_client_destroy (client);
   mongoc_cleanup();
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SH AUTHOR
MongoDB, Inc
.SH COPYRIGHT
2017-present, MongoDB, Inc
.\" Generated by docutils manpage writer.
.
