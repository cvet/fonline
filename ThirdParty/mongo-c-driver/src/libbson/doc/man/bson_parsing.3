.\" Man page generated from reStructuredText.
.
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.TH "BSON_PARSING" "3" "Aug 31, 2022" "1.23.0" "libbson"
.SH NAME
bson_parsing \- Parsing and Iterating BSON Documents
.SH PARSING
.sp
BSON documents are lazily parsed as necessary. To begin parsing a BSON document, use one of the provided Libbson functions to create a new \fI\%bson_t\fP from existing data such as \fI\%bson_new_from_data()\fP\&. This will make a copy of the data so that additional mutations may occur to the BSON document.
.sp
\fBTIP:\fP
.INDENT 0.0
.INDENT 3.5
If you only want to parse a BSON document and have no need to mutate it, you may use \fI\%bson_init_static()\fP to avoid making a copy of the data.
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
bson_t *b;

b = bson_new_from_data (my_data, my_data_len);
if (!b) {
   fprintf (stderr, \(dqThe specified length embedded in <my_data> did not match \(dq
                    \(dq<my_data_len>\en\(dq);
   return;
}

bson_destroy (b);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Only two checks are performed when creating a new \fI\%bson_t\fP from an existing buffer. First, the document must begin with the buffer length, matching what was expected by the caller. Second, the document must end with the expected trailing \fB\e0\fP byte.
.sp
To parse the document further we use a \fI\%bson_iter_t\fP to iterate the elements within the document. Let\(aqs print all of the field names in the document.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
bson_t *b;
bson_iter_t iter;

if ((b = bson_new_from_data (my_data, my_data_len))) {
   if (bson_iter_init (&iter, b)) {
      while (bson_iter_next (&iter)) {
         printf (\(dqFound element key: \e\(dq%s\e\(dq\en\(dq, bson_iter_key (&iter));
      }
   }
   bson_destroy (b);
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Converting a document to JSON uses a \fI\%bson_iter_t\fP and \fI\%bson_visitor_t\fP to iterate all fields of a BSON document recursively and generate a UTF\-8 encoded JSON string.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
bson_t *b;
char *json;

if ((b = bson_new_from_data (my_data, my_data_len))) {
   if ((json = bson_as_canonical_extended_json (b, NULL))) {
      printf (\(dq%s\en\(dq, json);
      bson_free (json);
   }
   bson_destroy (b);
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SH RECURSING INTO SUB-DOCUMENTS
.sp
Libbson provides convenient sub\-iterators to dive down into a sub\-document or sub\-array. Below is an example that will dive into a sub\-document named \(dqfoo\(dq and print it\(aqs field names.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
bson_iter_t iter;
bson_iter_t child;
char *json;

if (bson_iter_init_find (&iter, doc, \(dqfoo\(dq) &&
    BSON_ITER_HOLDS_DOCUMENT (&iter) && bson_iter_recurse (&iter, &child)) {
   while (bson_iter_next (&child)) {
      printf (\(dqFound sub\-key of \e\(dqfoo\e\(dq named \e\(dq%s\e\(dq\en\(dq,
              bson_iter_key (&child));
   }
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SH FINDING FIELDS USING DOT NOTATION
.sp
Using the \fI\%bson_iter_recurse()\fP function exemplified above, \fI\%bson_iter_find_descendant()\fP can find a field for you using the MongoDB style path notation such as \(dqfoo.bar.0.baz\(dq.
.sp
Let\(aqs create a document like \fB{\(dqfoo\(dq: {\(dqbar\(dq: [{\(dqbaz: 1}]}}\fP and locate the \fB\(dqbaz\(dq\fP field.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
bson_t *b;
bson_iter_t iter;
bson_iter_t baz;

b =
   BCON_NEW (\(dqfoo\(dq, \(dq{\(dq, \(dqbar\(dq, \(dq[\(dq, \(dq{\(dq, \(dqbaz\(dq, BCON_INT32 (1), \(dq}\(dq, \(dq]\(dq, \(dq}\(dq);

if (bson_iter_init (&iter, b) &&
    bson_iter_find_descendant (&iter, \(dqfoo.bar.0.baz\(dq, &baz) &&
    BSON_ITER_HOLDS_INT32 (&baz)) {
   printf (\(dqbaz = %d\en\(dq, bson_iter_int32 (&baz));
}

bson_destroy (b);
.ft P
.fi
.UNINDENT
.UNINDENT
.SH VALIDATING A BSON DOCUMENT
.sp
If all you want to do is validate that a BSON document is valid, you can use \fI\%bson_validate()\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
size_t err_offset;

if (!bson_validate (doc, BSON_VALIDATE_NONE, &err_offset)) {
   fprintf (stderr,
            \(dqThe document failed to validate at offset: %u\en\(dq,
            (unsigned) err_offset);
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
See the \fI\%bson_validate()\fP documentation for more information and examples.
.SH AUTHOR
MongoDB, Inc
.SH COPYRIGHT
2017-present, MongoDB, Inc
.\" Generated by docutils manpage writer.
.
