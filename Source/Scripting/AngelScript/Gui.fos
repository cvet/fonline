// FOS Client

///@ Enum CursorType Default = 0

///@ Setting CursorType Cursor
///@ Setting uint CursorData
///@ Setting CursorType DraggableCursor
///@ Setting bool MsgboxInvert

interface IDropMenu
{
    void Draw();
    void MouseDown(MouseButton button);
    void MouseUp(MouseButton button);
    bool PreMouseMove(int offsetX, int offsetY);
    void PostMouseMove(int offsetX, int offsetY);
    void InputLost();
    void Loop();
};

funcdef Screen CreateScreenFunc();
funcdef bool DragAndDropHandler(Object obj, Object target);

// Inheritance
// Object
//   Panel
//     Screen
//     Grid
//       ItemView
//     Button
//       CheckBox
//         RadioButton
//   Text
//     TextInput
//       Console
//     MessageBox

// Callbacks
// Object
//   void OnConstruct()
//   void OnInit()
//   void OnShow()
//   void OnShow( dict<string, string> params )
//   void OnHide()
//   void OnAppear()
//   void OnDisappear()
//   void OnDraw()
//   void OnPostDraw()
//   void OnMove( int deltaX, int deltaY )
//   void OnMouseDown( MouseButton button )
//   void OnMouseUp( MouseButton button, bool lost )
//   void OnMousePressed( MouseButton button )
//   void OnLMousePressed()
//   void OnRMousePressed()
//   void OnMouseClick( MouseButton button )
//   void OnLMouseClick()
//   void OnRMouseClick()
//   void OnMouseMove()
//   void OnGlobalMouseDown( MouseButton button )
//   void OnGlobalMouseUp( MouseButton button )
//   void OnGlobalMousePressed( MouseButton button )
//   void OnGlobalMouseClick( MouseButton button )
//   void OnGlobalMouseMove()
//   void OnInput()
//   void OnInput( KeyCode key )
//   void OnInput( string text )
//   void OnInput( KeyCode key, string text )
//   void OnGlobalInput( KeyCode key, string text )
//   void OnActiveChanged()
//   void OnFocusChanged()
//   void OnHoverChanged()
//   void OnDragChanged()
//   void OnResizeGrid( Object cell, uint cellIndex )
//   void OnDrawItem( Item item, Object cell, uint cellIndex )
// CheckBox
//   void OnCheckedChanged()
// ItemView
//   Item[] OnGetItems() - return all items for display
//   int OnCheckItem( Item item ) - return slot index if UseSorting == false; sorting value if UseSorting == true; < 0 to discard item

// API
// Object
//   bool Active
//   bool ActiveSelf
//   string Name
//   int PosX
//   int PosY
//   int AbsolutePosX
//   int AbsolutePosY
//   int Width
//   int Height
//   int Anchor
//   int Dock
//   bool IsDraggable
//   bool IsNotHittable
//   bool IsNotCatchable
//   bool CheckTransparentOnHit
//   bool IsFocused
//   bool IsPressed
//   bool IsHovered
//   bool IsDragged
//   uint ChildCount
//   Object Parent
//   Screen Screen
//   Grid Grid
//   uint CellIndex
//   void Init( Object parent )
//   void Remove()
//   void SetActive( bool active )
//   void SetPosition( int x, int y )
//   void SetPosition( string iniKey )
//   void SetSize( int w, int h )
//   void SetAnchor( int anchorStyles )
//   void SetDock( int dockStyle )
//   void SetColor( uint color )
//   void SetDraggable( bool enabled )
//   void SetNotHittable( bool enabled )
//   void SetNotCatchable( bool enabled )
//   void SetCheckTransparentOnHit( bool enabled )
//   Object FindMouseHit()
//   Object FindHit( int x, int y )
//   bool IsMouseHit()
//   bool IsHit( int x, int y )
//   void GetWholeSize( int& centerX, int& centerY, int& wholeWidth, int& wholeHeight, bool onlyChidren = false )
//   void Draw( int x, int y )
//   void Move( int deltaX, int deltaY )
//   void StartDragging()
//   void MouseClick( MouseButton button )
//   void Input( KeyCode key, string text )
//   Panel FindPanel( string name )
//   Text FindText( string name )
//   TextInput FindTextInput( string name )
//   Button FindButton( string name )
//   Object Find( string name, bool deepFind = true )
//   Object GetChild( uint index )
// Panel : Object
//   Sprite::Sprite BackgroundImage
//   int BackgroundImageLayout
//   void SetBackgroundImage( string imageName, int imageLayout = IMAGE_LAYOUT_NONE )
//   void SetBackgroundImage( hstring imageName, int imageLayout = IMAGE_LAYOUT_NONE )
//   void SetCropContent( bool enabled )
//   void SetAutoScroll( bool ver, bool hor )
//   void ModifyScroll( int ver, int hor )
//   bool CanModifyScroll( int ver, int hor )
// Text : Object
//   string Text (overridable)
//   int TextFont
//   uint TextColor
//   uint TextColorFocused
//   int TextFlags
//   void SetText( string text, int font, int flags )
//   void SetText( string text )
//   void SetTextWithResize( string text )
//   void SetTextFont( int font )
//   void SetTextFlags( int flags )
//   void SetTextColor( uint color )
//   void SetTextFocusedColor( uint color )
// TextInput : Text : Object
//   uint InputLength
//   bool IsTextPassword
//   string PasswordChar
//   void SetInputLength( uint length )
//   void SetInputPassword( string passwordChar )
//   void SetCarriage( bool enable )
// Button : Panel : Object
//   Sprite::Sprite PressedImage
//   int PressedImageLayout
//   Sprite::Sprite HoverImage
//   int HoverImageLayout
//   bool IsSwitched
//   bool IsDisabled
//   void SetPressedImage( string imageName, int imageLayout = IMAGE_LAYOUT_NONE )
//   void SetPressedImage( hstring imageName, int imageLayout = IMAGE_LAYOUT_NONE )
//   void SetHoverImage( string imageName, int imageLayout = IMAGE_LAYOUT_NONE )
//   void SetHoverImage( hstring imageName, int imageLayout = IMAGE_LAYOUT_NONE )
//   void SetDisabledImage( string imageName, int imageLayout = IMAGE_LAYOUT_NONE )
//   void SetDisabledImage( hstring imageName, int imageLayout = IMAGE_LAYOUT_NONE )
//   void SetSwitch( bool enabled )
//   void SetCondition( bool enabled )
// CheckBox : Button : Panel : Object
//   bool IsChecked
//   void SetChecked( bool checked )
// RadioButton : CheckBox : Button : Panel : Object
// Screen : Panel : Object
//   int Index
//   bool IsMain
//   bool IsModal
//   bool IsMultiinstance
//   bool IsCloseOnMiss
//   bool IsCanMove
//   bool IsMoveIgnoreBorders
//   int[] AvailableCursors
//   int Cursor
//   bool IsOnTop
//   void SetModal( bool enabled )
//   void SetMultiinstance( bool enabled )
//   void SetCloseOnMiss( bool enabled )
//   void SetCanMove( bool enabled, bool ignoreBorders )
//   void SetAvailableCursors( CursorType[] cursors )
// Grid : Panel : Object
//   string CellPrototype
//   uint GridSize
//   int Columns
//   Object[] Cells
//   void ResizeGrid( uint size )
//   void RefreshContentPositions()
//   void SetCellPrototype( string name )
//   void SetGridSize( uint size )
//   void SetColumns( int length )
//   void SetPadding( int x, int y )
// MessageBox : Text : Object
//   string[] MessageTexts
//   int[] MessageTypes
//   string[] MessageTimes
//   bool[] DisplayedMessages
//   bool InvertMessages
//   void AddMessage( string text, int type = FOMB_GAME )
//   void SetDisplayedMessages( int[] messageTypes )
//   void ChangeDisplayedMessage( int messageType, bool enable )
//   void SetInvertMessages( bool invert )
//   void ClearMessages()
// Console : TextInput : Text : Object
//   string HistoryStorageName
//   string[] History
//   uint HistoryMaxLength
//   void Activate()
//   void Deactivate()
//   void SendText()
//   void Toggle() // Automatically manage calls of Activate / Deactivate / SendText
//   void SetHistoryStorage( string storageName )
//   void SetHistoryMaxLength( uint length )
// ItemView : Grid : Panel : Object
//   int UserData
//   int UserDataExt
//   bool UseSorting
//   Item[] Items
//   Item GetItem( uint cellIndex )
//   void Resort()
//   void SetUserData( int data )
//   void SetUserDataExt( int data )
//   void SetUseSorting( bool enable )

class Object
{
    bool get_Active() final
    {
        return _ActiveSelf && (_Parent != null ? _Parent.Active : true);
    }
    bool get_ActiveSelf() final
    {
        return _ActiveSelf;
    }
    string get_Name() final
    {
        return _Name;
    }
    int get_PosX() final
    {
        return _Parent != null ? _AbsolutePosX - _Parent._AbsolutePosX : _AbsolutePosX;
    }
    int get_PosY() final
    {
        return _Parent != null ? _AbsolutePosY - _Parent._AbsolutePosY : _AbsolutePosY;
    }
    int get_AbsolutePosX() final
    {
        return _AbsolutePosX;
    }
    int get_AbsolutePosY() final
    {
        return _AbsolutePosY;
    }
    int get_Width() final
    {
        return _Width;
    }
    int get_Height() final
    {
        return _Height;
    }
    int get_Anchor() final
    {
        return _Anchor;
    }
    int get_Dock() final
    {
        return _Dock;
    }
    int get_Color() final
    {
        return _Color;
    }
    bool get_IsDraggable() final
    {
        return _IsDraggable;
    }
    bool get_IsNotHittable() final
    {
        return _IsNotHittable;
    }
    bool get_IsNotCatchable() final
    {
        return _IsNotCatchable;
    }
    bool get_CheckTransparentOnHit() final
    {
        return _CheckTransparentOnHit;
    }
    bool get_IsFocused() final
    {
        return _IsFocused;
    }
    bool get_IsPressed() final
    {
        return _IsPressed;
    }
    bool get_IsHovered() final
    {
        return _IsHovered;
    }
    bool get_IsDragged() final
    {
        return _IsDragged || (_Parent != null && _Parent.IsDragged);
    }
    uint get_ChildCount() final
    {
        return _Children.length();
    }
    Object get_Parent() final
    {
        return _Parent;
    }
    Screen get_Screen() final
    {
        return _Parent != null ? _Parent.Screen : cast<Screen>(this);
    }
    Grid get_Grid() final
    {
        return _Grid;
    }
    uint get_CellIndex() final
    {
        return _CellIndex;
    }

    bool _ActiveSelf;
    string _Name;
    int _BasePosX;
    int _BasePosY;
    int _BaseWidth;
    int _BaseHeight;
    int _AbsolutePosX;
    int _AbsolutePosY;
    int _Width;
    int _Height;
    int _Anchor;
    int _Dock;
    uint _Color;
    bool _IsDragged;
    bool _IsDraggable;
    bool _IsNotHittable;
    bool _IsNotCatchable;
    bool _CheckTransparentOnHit;
    bool _DeferredMousePressed;
    bool _IsFocused;
    bool _IsPressed;
    bool _IsHovered;
    MouseButton _PressedButton;
    int _PressedX;
    int _PressedY;
    Object _Parent;
    Object[] _Children;
    Grid _Grid;
    uint _CellIndex;

    // Callbacks
    void OnConstruct()
    {
    }
    void OnInit()
    {
    }
    void OnShow()
    {
    }
    void OnShow(dict<string, string> params)
    {
    }
    void OnHide()
    {
    }
    void OnAppear()
    {
    }
    void OnDisappear()
    {
    }
    void OnRemove()
    {
    }
    void OnDraw()
    {
    }
    void OnPostDraw()
    {
    }
    void OnMove(int deltaX, int deltaY)
    {
    }
    void OnMouseDown(MouseButton button)
    {
    }
    void OnMouseUp(MouseButton button, bool lost)
    {
    }
    void OnMousePressed(MouseButton button)
    {
    }
    void OnLMousePressed()
    {
    }
    void OnRMousePressed()
    {
    }
    void OnMouseClick(MouseButton button)
    {
    }
    void OnLMouseClick()
    {
    }
    void OnRMouseClick()
    {
    }
    void OnMouseMove()
    {
    }
    void OnGlobalMouseDown(MouseButton button)
    {
    }
    void OnGlobalMouseUp(MouseButton button)
    {
    }
    void OnGlobalMousePressed(MouseButton button)
    {
    }
    void OnGlobalMouseClick(MouseButton button)
    {
    }
    void OnGlobalMouseMove()
    {
    }
    void OnInput()
    {
    }
    void OnInput(KeyCode key)
    {
    }
    void OnInput(string text)
    {
    }
    void OnInput(KeyCode key, string text)
    {
    }
    void OnGlobalInput(KeyCode key, string text)
    {
    }
    void OnActiveChanged()
    {
    }
    void OnFocusChanged()
    {
    }
    void OnHoverChanged()
    {
    }
    void OnDragChanged()
    {
    }
    void OnResizeGrid(Object cell, uint cellIndex)
    {
    }
    void OnDrawItem(Item item, Object cell, uint cellIndex)
    {
    }

    Object()
    {
        _Children = array<Object>();
    }

    void Init(Object parent)
    {
        _ActiveSelf = true;
        _Name = reflection::typeof<Object>(this).nameWithoutNamespace;

        if (_Parent != null)
            _Parent._Children.removeAt(_Parent._Children.findByRef(this));
        _Parent = parent;
        if (parent != null)
            parent._Children.insertLast(this);

        _Construct();
        OnConstruct();

        Screen screen = Screen;
        if (screen != null && screen._IsRegistered)
            _Init();
    }

    void _Construct()
    {
        // Virtual
    }

    void _FixClone()
    {
        _Parent = null;
        _Children = array<Object>();
    }

    void _Init()
    {
        for (uint i = 0; i < _Children.length(); i++)
            _Children[i]._Init();
        OnInit();
        _RefreshPosition();
    }

    void _Show(dict<string, string> params)
    {
        OnShow();
        OnShow(params);
        for (uint i = 0; i < _Children.length(); i++)
            _Children[i]._Show(params);
    }

    void _Hide()
    {
        OnHide();
        for (uint i = 0; i < _Children.length(); i++)
            _Children[i]._Hide();
    }

    void _Appear()
    {
        OnAppear();
        for (uint i = 0; i < _Children.length(); i++)
            _Children[i]._Appear();
    }

    void _Disappear()
    {
        OnDisappear();
        for (uint i = 0; i < _Children.length(); i++)
            _Children[i]._Disappear();
    }

    void _DragChanged()
    {
        OnDragChanged();
        for (uint i = 0; i < _Children.length(); i++)
            _Children[i]._DragChanged();
    }

    void Remove()
    {
        if (_Parent != null) {
            _Parent._Children.removeAt(_Parent._Children.findByRef(this));
            _Parent = null;
        }

        _Remove();

        _ActiveSelf = false;
    }

    void _Remove()
    {
        OnRemove();
        for (uint i = 0; i < _Children.length(); i++)
            _Children[i]._Remove();
    }

    void _Reload(bool reconstruct, bool refreshPosition)
    {
        if (reconstruct)
            OnConstruct();
        if (refreshPosition)
            _RefreshPosition();

        for (uint i = 0; i < _Children.length(); i++)
            _Children[i]._Reload(reconstruct, refreshPosition);
    }

    void _DrawCallback()
    {
        // Draw item callback
        if (_Grid != null) {
            ItemView itemView = cast<ItemView>(_Grid);
            if (itemView != null)
                OnDrawItem(itemView.GetItem(_CellIndex), this, _CellIndex);
        }

        // Common draw callback
        OnDraw();
    }

    void _Draw(bool callCallback)
    {
        if (callCallback)
            _DrawCallback();

        // _Children
        for (uint i = 0; i < _Children.length(); i++) {
            Object child = _Children[i];
            if (child._ActiveSelf && !child._IsDragged)
                child._Draw(true);
        }

        if (callCallback)
            OnPostDraw();
    }

    void Draw(int x, int y)
    {
        int dx = x - _AbsolutePosX;
        int dy = y - _AbsolutePosY;
        _Move(dx, dy, false, false);
        _Draw(true);
        _Move(-dx, -dy, false, false);
    }

    void Move(int deltaX, int deltaY)
    {
        _Move(deltaX, deltaY, true, true);
    }

    void _Move(int deltaX, int deltaY, bool callCallback, bool moveBasePos)
    {
        _AbsolutePosX += deltaX;
        _AbsolutePosY += deltaY;

        if (moveBasePos) {
            _BasePosX += deltaX;
            _BasePosY += deltaY;
        }

        for (uint i = 0; i < _Children.length(); i++)
            _Children[i]._Move(deltaX, deltaY, false, false);

        if (callCallback)
            _MoveCallback(deltaX, deltaY);
    }

    void _MoveCallback(int deltaX, int deltaY)
    {
        OnMove(deltaX, deltaY);
        for (uint i = 0; i < _Children.length(); i++)
            _Children[i]._MoveCallback(deltaX, deltaY);
    }

    bool _IsCatchable()
    {
        bool result = (!_IsNotCatchable && !_IsDraggable && cast<Panel>(this) != null && cast<Button>(this) == null && cast<Grid>(this) == null);
        return result && (Parent != null ? Parent._IsCatchable() : true);
    }

    Object FindMouseHit()
    {
        return FindHit(Settings.MouseX, Settings.MouseY);
    }

    Object FindHit(int x, int y)
    {
        // Check children
        for (int i = int(_Children.length()) - 1; i >= 0; i--) {
            Object obj = _Children[i].FindHit(x, y);
            if (obj != null)
                return obj;
        }

        // Check own
        if (IsHit(x, y))
            return this;

        // No collision found
        return null;
    }

    bool IsMouseHit()
    {
        return IsHit(Settings.MouseX, Settings.MouseY);
    }

    bool IsHit(int x, int y)
    {
        return Active && !_IsNotHittable && _Width > 0 && _Height > 0 && Math::IsCollision(x, y, _AbsolutePosX, _AbsolutePosY, _Width, _Height) &&
               !_IsCropped(x, y);
    }

    bool _IsCropped(int x, int y)
    {
        Object obj = Parent;
        while (obj != null) {
            Panel panel = cast<Panel>(obj);
            if (panel != null && panel._CropContent && !Math::IsCollision(x, y, obj._AbsolutePosX, obj._AbsolutePosY, obj._Width, obj._Height))
                return true;
            obj = obj.Parent;
        }
        return false;
    }

    void _GetWholeSizeRect(int[] rect)
    {
        int l = _AbsolutePosX;
        int t = _AbsolutePosY;
        int r = l + Width;
        int b = t + Height;

        if (l < rect[0])
            rect[0] = l;
        if (t < rect[1])
            rect[1] = t;
        if (r > rect[2])
            rect[2] = r;
        if (b > rect[3])
            rect[3] = b;

        for (uint i = 0; i < _Children.length(); i++)
            _Children[i]._GetWholeSizeRect(rect);
    }

    void GetWholeSize(int& centerX, int& centerY, int& wholeWidth, int& wholeHeight, bool onlyChidren = false)
    {
        int[] rect = {1000000000, 1000000000, -1000000000, -1000000000};
        if (!onlyChidren) {
            _GetWholeSizeRect(rect);
        }
        else if (_Children.length() > 0) {
            for (uint i = 0; i < _Children.length(); i++)
                _Children[i]._GetWholeSizeRect(rect);
        }
        else {
            rect[0] = rect[1] = rect[2] = rect[3] = 0;
        }
        wholeWidth = rect[2] - rect[0];
        wholeHeight = rect[3] - rect[1];
        centerX = rect[0] + wholeWidth / 2;
        centerY = rect[1] + wholeHeight / 2;
    }

    void _MouseDown(MouseButton button)
    {
        _IsPressed = true;
        _PressedButton = button;
        _PressedX = Settings.MouseX;
        _PressedY = Settings.MouseY;
        OnMouseDown(button);

        if (_IsDraggable && _PressedButton == MouseButton::Left) {
            bool draggableCursor = (Settings.DraggableCursor != CursorType::Default && Settings.Cursor == Settings.DraggableCursor);
            if (draggableCursor) {
                _IsDragged = true;
                _DragChanged();
            }
        }

        if (!_DeferredMousePressed) {
            Screen._GlobalMousePressed(button);
            _MousePressed(button);
        }
    }

    void StartDragging()
    {
        if (_IsDraggable && !_IsDragged && _IsPressed && _PressedButton == MouseButton::Left && !IsDragged) {
            _IsDragged = true;
            _DragChanged();
        }
    }

    void _MousePressed(MouseButton button)
    {
        OnMousePressed(button);
        if (button == MouseButton::Left)
            OnLMousePressed();
        else if (button == MouseButton::Right)
            OnRMousePressed();

        _MousePressedUnder(button);
    }

    void _MousePressedUnder(MouseButton button)
    {
        if (Parent != null)
            Parent._MousePressedUnder(button);
    }

    void _MouseUp(bool lost)
    {
        _IsPressed = false;

        if (_DeferredMousePressed) {
            Screen._GlobalMousePressed(_PressedButton);
            _MousePressed(_PressedButton);
        }

        OnMouseUp(_PressedButton, lost);

        if (_IsDragged) {
            _IsDragged = false;
            _DragChanged();
        }
    }

    void MouseClick(MouseButton button)
    {
        OnMouseClick(button);
        if (button == MouseButton::Left)
            OnLMouseClick();
        else if (button == MouseButton::Right)
            OnRMouseClick();
    }

    void _MouseMove()
    {
        OnMouseMove();
    }

    void _GlobalMouseDown(MouseButton button)
    {
        OnGlobalMouseDown(button);
        for (uint i = 0; i < _Children.length(); i++)
            _Children[i]._GlobalMouseDown(button);
    }

    void _GlobalMouseUp(MouseButton button)
    {
        OnGlobalMouseUp(button);
        for (uint i = 0; i < _Children.length(); i++)
            _Children[i]._GlobalMouseUp(button);
    }

    void _GlobalMousePressed(MouseButton button)
    {
        OnGlobalMousePressed(button);
        for (uint i = 0; i < _Children.length(); i++)
            _Children[i]._GlobalMousePressed(button);
    }

    void _GlobalMouseClick(MouseButton button)
    {
        OnGlobalMouseClick(button);
        for (uint i = 0; i < _Children.length(); i++)
            _Children[i]._GlobalMouseClick(button);
    }

    void _GlobalMouseMove()
    {
        OnGlobalMouseMove();
        for (uint i = 0; i < _Children.length(); i++)
            _Children[i]._GlobalMouseMove();
    }

    void Input(KeyCode key, string text)
    {
        OnInput();
        if (text.isEmpty())
            OnInput(key);
        else
            OnInput(text);
        OnInput(key, text);
    }

    void _GlobalInput(KeyCode key, string text)
    {
        OnGlobalInput(key, text);
        for (uint i = 0; i < _Children.length(); i++)
            _Children[i]._GlobalInput(key, text);
    }

    void _Focus()
    {
        if (!_IsFocused) {
            _IsFocused = true;
            OnFocusChanged();
        }
    }

    void _Unfocus()
    {
        if (_IsFocused) {
            _IsFocused = false;
            OnFocusChanged();
        }
    }

    void _Hover()
    {
        if (!_IsHovered) {
            _IsHovered = true;
            OnHoverChanged();
        }
    }

    void _Unhover()
    {
        if (_IsHovered) {
            _IsHovered = false;
            OnHoverChanged();
        }
    }

    Object _Clone(Object parent)
    {
        Object newObject;
        reflection::typeof<Object>(this).instantiate(this, newObject);
        newObject._FixClone();
        newObject._Parent = parent;
        if (parent != null)
            parent._Children.insertLast(newObject);
        newObject.OnConstruct();
        for (uint i = 0; i < _Children.length(); i++)
            _Children[i]._Clone(newObject);
        return newObject;
    }

    Panel FindPanel(string name)
    {
        return cast<Panel>(Find(name));
    }

    Text FindText(string name)
    {
        return cast<Text>(Find(name));
    }

    TextInput FindTextInput(string name)
    {
        return cast<TextInput>(Find(name));
    }

    Button FindButton(string name)
    {
        return cast<Button>(Find(name));
    }

    Object Find(string name, bool deepFind = true)
    {
        for (uint i = 0; i < _Children.length(); i++) {
            Object child = _Children[i];
            if (!child._Name.isEmpty() && child._Name == name)
                return child;

            if (deepFind) {
                Object obj = child.Find(name);
                if (obj != null)
                    return obj;
            }
        }
        return null;
    }

    Object GetChild(uint index)
    {
        return _Children[index];
    }

    void _RefreshPosition()
    {
        // Base data
        _Width = _BaseWidth;
        _Height = _BaseHeight;
        int parentAbsolutePosX = (_Parent != null ? _Parent._AbsolutePosX : 0);
        int parentAbsolutePosY = (_Parent != null ? _Parent._AbsolutePosY : 0);
        int parentWidth = (_Parent != null ? _Parent._Width : Settings.ScreenWidth);
        int parentHeight = (_Parent != null ? _Parent._Height : Settings.ScreenHeight);
        int parentBaseWidth = (_Parent != null ? _Parent._BaseWidth : _BaseWidth);
        int parentBaseHeight = (_Parent != null ? _Parent._BaseHeight : _BaseHeight);

        // Dock
        int newPosX;
        int newPosY;
        if (_Dock != 0) {
            if (_Dock == DOCK_LEFT) {
                newPosX = parentAbsolutePosX;
                newPosY = parentAbsolutePosY;
                _Height = parentHeight;
            }
            else if (_Dock == DOCK_RIGHT) {
                newPosX = parentAbsolutePosX + parentWidth - _Width;
                newPosY = parentAbsolutePosY;
                _Height = parentHeight;
            }
            else if (_Dock == DOCK_TOP) {
                newPosX = parentAbsolutePosX;
                newPosY = parentAbsolutePosY;
                _Width = parentWidth;
            }
            else if (_Dock == DOCK_BOTTOM) {
                newPosX = parentAbsolutePosX;
                newPosY = parentAbsolutePosY + parentHeight - _Height;
                _Width = parentWidth;
            }
            else if (_Dock == DOCK_FILL) {
                newPosX = parentAbsolutePosX;
                newPosY = parentAbsolutePosY;
                _Width = parentWidth;
                _Height = parentHeight;
            }
            else {
                newPosX = _BasePosX + parentAbsolutePosX;
                newPosY = _BasePosY + parentAbsolutePosY;
            }
        }
        // Anchor
        else {
            if ((_Anchor & ANCHOR_LEFT) != 0)
                newPosX = parentAbsolutePosX + _BasePosX;
            else if ((_Anchor & ANCHOR_RIGHT) != 0)
                newPosX = parentAbsolutePosX + _BasePosX + (parentWidth - parentBaseWidth);
            else
                newPosX = parentAbsolutePosX + _BasePosX + (parentWidth - parentBaseWidth) / 2;

            if ((_Anchor & ANCHOR_TOP) != 0)
                newPosY = parentAbsolutePosY + _BasePosY;
            else if ((_Anchor & ANCHOR_BOTTOM) != 0)
                newPosY = parentAbsolutePosY + _BasePosY + (parentHeight - parentBaseHeight);
            else
                newPosY = parentAbsolutePosY + _BasePosY + (parentHeight - parentBaseHeight) / 2;
        }

        // Move control
        if (newPosX != _AbsolutePosX || newPosY != _AbsolutePosY)
            _Move(newPosX - _AbsolutePosX, newPosY - _AbsolutePosY, false, false);
    }

    void _SizeChanged()
    {
        // Internal callback
    }

    // Options
    void SetName(string name)
    {
        _Name = name;
    }

    void SetActive(bool active)
    {
        if (_ActiveSelf != active) {
            _ActiveSelf = active;
            _ActiveChanged();
        }
    }

    void _ActiveChanged()
    {
        OnActiveChanged();
        for (uint i = 0; i < _Children.length(); i++)
            _Children[i]._ActiveChanged();
    }

    void SetPosition(int x, int y)
    {
        if (_BasePosX == x && _BasePosY == y)
            return;

        _BasePosX = x;
        _BasePosY = y;
        _RefreshPosition();
    }

    void SetSize(int w, int h)
    {
        if (_BaseWidth == w && _BaseHeight == h)
            return;

        _BaseWidth = w;
        _BaseHeight = h;
        _RefreshPosition();
        _SizeChanged();
    }

    void SetAnchor(int anchorStyles)
    {
        if (_Anchor == anchorStyles)
            return;

        _Anchor = anchorStyles;
        _RefreshPosition();
    }

    void SetDock(int dockStyle)
    {
        if (_Dock == dockStyle)
            return;

        _Dock = dockStyle;
        _RefreshPosition();
    }

    void SetColor(uint color)
    {
        _Color = color;
    }

    void SetDraggable(bool enabled)
    {
        _IsDraggable = enabled;
    }

    void SetNotHittable(bool enabled)
    {
        _IsNotHittable = enabled;
    }

    void SetNotCatchable(bool enabled)
    {
        _IsNotCatchable = enabled;
    }

    void SetCheckTransparentOnHit(bool enabled)
    {
        _CheckTransparentOnHit = enabled;
    }

    void SetDeferredMousePressed(bool enabled)
    {
        _DeferredMousePressed = enabled;
    }
};

class Panel : Object
{
    Sprite::Sprite get_BackgroundImage() final
    {
        return _BackgroundImage;
    }
    int get_BackgroundImageLayout() final
    {
        return _BackgroundImage != null ? _BackgroundImage.Layout : IMAGE_LAYOUT_NONE;
    }
    bool get_IsVerticalScroll() final
    {
        return _IsVerticalScroll;
    }
    bool get_IsHorizontalScroll() final
    {
        return _IsHorizontalScroll;
    }
    int get_VerticalScrollPercent() final
    {
        return _VerticalScrollPercent;
    }
    int get_HorizontalScrollPercent() final
    {
        return _HorizontalScrollPercent;
    }

    Sprite::Sprite _BackgroundImage;
    bool _CropContent;
    bool _IsVerticalScroll;
    bool _IsHorizontalScroll;
    int _VerticalScroll;
    int _HorizontalScroll;
    int _VerticalScrollPercent;
    int _HorizontalScrollPercent;

    bool IsHit(int x, int y) override
    {
        if (Object::IsHit(x, y)) {
            if (_CheckTransparentOnHit && _BackgroundImage != null)
                return (GetSpritePixelColor(_BackgroundImage.Id, _BackgroundImage.Frame, x - _AbsolutePosX, y - _AbsolutePosY) & 0xFF000000) != 0;
            return true;
        }
        return false;
    }

    void _Draw(bool callCallback) override
    {
        _ModifyScroll(0, 0);

        bool crop = _CropContent;
        if (crop)
            PushDrawScissor(AbsolutePosX, AbsolutePosY, Width, Height);

        if (callCallback)
            _DrawCallback();

        // Normal sprite
        if (_BackgroundImage != null)
            _DrawImage(_BackgroundImage);

        Object::_Draw(false);

        if (callCallback)
            OnPostDraw();

        if (crop)
            PopDrawScissor();
    }

    void _DrawImage(Sprite::Sprite image)
    {
        if (_Width > 0 && _Height > 0)
            image.Draw(_AbsolutePosX, _AbsolutePosY, _Width, _Height, -1, -1, -1, _Color);
    }

    void SetBackgroundImage(string imageName, int imageLayout = IMAGE_LAYOUT_NONE)
    {
        _SetImage(_BackgroundImage, imageName, imageLayout);
    }

    void SetBackgroundImage(hstring imageName, int imageLayout = IMAGE_LAYOUT_NONE)
    {
        _SetImage(_BackgroundImage, imageName, imageLayout);
    }

    void _SetImage(Sprite::Sprite& curImage, string imageName, int imageLayout)
    {
        _SetImage(curImage, hstring(imageName), imageLayout);
    }

    void _SetImage(Sprite::Sprite& curImage, hstring imageName, int imageLayout)
    {
        if (curImage != null && curImage.LoadedName == imageName)
            return;

        curImage = null;
        if (imageName != hstring()) {
            Sprite::Sprite spr = Sprite::Sprite();
            if (spr.Load(imageName))
                curImage = spr;
        }

        if (curImage != null)
            curImage.Layout = imageLayout;

        if (curImage != null && (imageLayout == IMAGE_LAYOUT_NONE || (_BaseWidth == 0 && _BaseHeight == 0)))
            SetSize(curImage.Width, curImage.Height);
    }

    void _MousePressedUnder(MouseButton button) override
    {
        if (_IsVerticalScroll && (button == MouseButton::WheelUp || button == MouseButton::WheelDown)) {
            int dy = 0;
            if (button == MouseButton::WheelUp)
                dy = -1;
            else if (button == MouseButton::WheelDown)
                dy = 1;

            if (dy != 0)
                _ModifyScroll(dy * 10, 0);

            // Stop processing
            return;
        }

        Object::_MousePressedUnder(button);
    }

    void ModifyScroll(int ver, int hor)
    {
        _ModifyScroll(ver, hor);
    }

    bool CanModifyScroll(int ver, int hor)
    {
        return _ModifyScroll(ver, hor, true);
    }

    void SetScrollPercent(int verPercent, int horPercent)
    {
        if (!_IsVerticalScroll && !_IsHorizontalScroll)
            return;

        int maxVerScroll = 0, maxHorScroll = 0;
        _GetScrollableSize(maxVerScroll, maxHorScroll);

        int newVer = (maxVerScroll > 0 ? maxVerScroll * verPercent / 100 : 0);
        int newHor = (maxHorScroll > 0 ? maxHorScroll * horPercent / 100 : 0);

        if (newVer != _VerticalScroll || newHor != _HorizontalScroll)
            _ModifyScroll(newVer - _VerticalScroll, newHor - _HorizontalScroll);
    }

    bool _ModifyScroll(int ver, int hor, bool onlyCheck = false)
    {
        if (!_IsVerticalScroll && !_IsHorizontalScroll)
            return false;

        int curVer = _VerticalScroll;
        int curHor = _HorizontalScroll;
        int oldVer = curVer;
        int oldHor = curHor;

        if (_IsVerticalScroll)
            curVer += ver;
        if (_IsHorizontalScroll)
            curHor += hor;

        int maxVerScroll = 0, maxHorScroll = 0;
        _GetScrollableSize(maxVerScroll, maxHorScroll);

        if (_IsVerticalScroll) {
            if (curVer > maxVerScroll)
                curVer = maxVerScroll;
            if (curVer < 0)
                curVer = 0;
        }
        if (_IsHorizontalScroll) {
            if (curHor > maxHorScroll)
                curHor = maxHorScroll;
            if (curHor < 0)
                curHor = 0;
        }

        if (!onlyCheck || (ver == 0 && hor == 0)) {
            _VerticalScrollPercent = (maxVerScroll > 0 ? curVer * 100 / maxVerScroll : 0);
            _HorizontalScrollPercent = (maxHorScroll > 0 ? curHor * 100 / maxHorScroll : 0);
        }

        if (curVer != oldVer || curHor != oldHor) {
            if (!onlyCheck) {
                _VerticalScroll = curVer;
                _HorizontalScroll = curHor;
                for (uint i = 0; i < _Children.length(); i++)
                    _Children[i]._Move(-(curHor - oldHor), -(curVer - oldVer), true, false);
            }
            return true;
        }
        return false;
    }

    void _GetScrollableSize(int& maxVerScroll, int& maxHorScroll)
    {
        if (!_IsVerticalScroll && !_IsHorizontalScroll)
            return;

        int centerX = 0, centerY = 0, wholeWidth = 0, wholeHeight = 0;
        GetWholeSize(centerX, centerY, wholeWidth, wholeHeight, true);
        if (_IsVerticalScroll)
            maxVerScroll = wholeHeight - Height + ((centerY + _VerticalScroll) - wholeHeight / 2 - AbsolutePosY);
        if (_IsHorizontalScroll)
            maxHorScroll = wholeWidth - Width + ((centerX + _HorizontalScroll) - wholeWidth / 2 - AbsolutePosX);
    }

    void SetCropContent(bool enabled)
    {
        _CropContent = enabled;
    }

    void SetAutoScroll(bool ver, bool hor)
    {
        _IsVerticalScroll = ver;
        _IsHorizontalScroll = hor;
    }
};

class Text : Object
{
    string get_Text()
    {
        return _Text;
    }
    void set_Text(string value)
    {
        _Text = value;
    }
    int get_TextFont() final
    {
        return _TextFont;
    }
    uint get_TextColor() final
    {
        return _TextColor;
    }
    uint get_TextColorFocused() final
    {
        return _TextColorFocused;
    }
    int get_TextFlags() final
    {
        return _TextFlags;
    }

    string _Text;
    int _TextFont;
    uint _TextColor;
    uint _TextColorFocused;
    int _TextFlags;

    void _Construct() override
    {
        Object::_Construct();

        _TextFont = FONT_DEFAULT;
        _TextColor = COLOR_TEXT;
    }

    void _Draw(bool callCallback) override
    {
        if (callCallback)
            _DrawCallback();

        // Text
        string text = Text;
        if (text.length() > 0) {
            uint color = (_IsFocused && _TextColorFocused != 0 ? _TextColorFocused : _TextColor);
            DrawText(text, _AbsolutePosX, _AbsolutePosY, _Width, _Height, color, _TextFont, _TextFlags);
        }

        Object::_Draw(false);

        if (callCallback)
            OnPostDraw();
    }

    void SetText(string text, int font, int flags)
    {
        if (!text.isEmpty())
            _Text = text;
        else
            _Text = "";

        _TextFont = font;
        _TextFlags = flags;
    }

    void SetText(string text)
    {
        if (!text.isEmpty())
            _Text = text;
        else
            _Text = "";
    }

    void SetTextWithResize(string text)
    {
        int tw = 0, th = 0, lines = 0;
        GetTextInfo(text, Width, 1000, _TextFont, _TextFlags, tw, th, lines);
        SetSize(_Width, th + 5);
        SetText(text);
    }

    void SetTextFont(int font)
    {
        _TextFont = font;
    }

    void SetTextFlags(int flags)
    {
        _TextFlags = flags;
    }

    void SetTextColor(uint color)
    {
        _TextColor = color;
    }

    void SetTextFocusedColor(uint color)
    {
        _TextColorFocused = color;
    }
};

const int PasswordShowTime = 1000;
class TextInput : Text
{
    uint get_InputLength() final
    {
        return _InputLength;
    }
    bool get_IsTextPassword() final
    {
        return _IsTextPassword;
    }
    string get_PasswordChar() final
    {
        return _PasswordChar;
    }

    uint _InputLength;
    bool _IsTextPassword;
    string _PasswordChar;
    uint _PasswordTime;
    int _CarriagePos;

    void _Construct() override
    {
        Text::_Construct();

        SetCarriage(false);
        _TextColorFocused = COLOR_TEXT_FOCUSED;
    }

    void _Focus() override
    {
        CustomCall("SetScreenKeyboard true");

        Text::_Focus();
    }

    void _Unfocus() override
    {
        if (CurConsole == null || !CurConsole.Active)
            CustomCall("SetScreenKeyboard false");

        Text::_Unfocus();
    }

    void _Draw(bool callCallback) override
    {
        if (callCallback)
            _DrawCallback();

        // Text
        string text = _Text;
        if (_IsTextPassword && text.length() > 0) {
            string rawText = text;
            text = "";
            for (uint i = 0; i < rawText.length(); i++)
                text += _PasswordChar;
            if (GetTick() - _PasswordTime <= PasswordShowTime)
                text[text.length() - 1] = rawText[text.length() - 1];
        }
        if (_CarriagePos != -1 && _IsFocused) {
            if (_CarriagePos < 0)
                _CarriagePos = 0;
            if (_CarriagePos > int(text.length()))
                _CarriagePos = text.length();
            text = text.substr(0, _CarriagePos) + (GetTick() % 800 < 400 ? "!" : ".") + text.substr(_CarriagePos);
        }
        if (text.length() > 0) {
            uint color = (_IsFocused && _TextColorFocused != 0 ? _TextColorFocused : _TextColor);
            DrawText(text, _AbsolutePosX, _AbsolutePosY, _Width, _Height, color, _TextFont, _TextFlags);
        }

        Object::_Draw(false);

        if (callCallback)
            OnPostDraw();
    }

    void Input(KeyCode key, string text) override
    {
        uint oldLen = _Text.length();
        _ProcessKey(key, text);
        while (_InputLength != 0 && _Text.length() > _InputLength)
            _Text = _Text.substr(0, _Text.length() - 1);
        if (_IsTextPassword)
            _PasswordTime = (_Text.length() > oldLen ? GetTick() : 0);

        Text::Input(key, text);
    }

    void _ProcessKey(KeyCode key, string text)
    {
        if (_CarriagePos != -1) {
            if (_CarriagePos < 0)
                _CarriagePos = 0;
            else if (_CarriagePos > int(_Text.length()))
                _CarriagePos = _Text.length();

            if (key == KeyCode::Back) {
                if (_CarriagePos > 0) {
                    _Text[_CarriagePos - 1] = "";
                    _CarriagePos--;
                }
            }
            else if (key == KeyCode::Delete) {
                if (_CarriagePos < int(_Text.length()))
                    _Text[_CarriagePos] = "";
            }
            else if (key == KeyCode::Right) {
                if (_CarriagePos < int(_Text.length()))
                    _CarriagePos++;
            }
            else if (key == KeyCode::Left) {
                if (_CarriagePos > 0)
                    _CarriagePos--;
            }
            else if (key == KeyCode::Home) {
                _CarriagePos = 0;
            }
            else if (key == KeyCode::End) {
                _CarriagePos = _Text.length();
            }
            else if (!text.isEmpty()) {
                _Text = _Text.substr(0, _CarriagePos) + text + _Text.substr(_CarriagePos);
                _CarriagePos += text.length();
            }
        }
        else {
            if (key == KeyCode::Back) {
                if (_Text.length() > 0)
                    _Text[_Text.length() - 1] = "";
            }
            else if (!text.isEmpty()) {
                _Text += text;
            }
        }
    }

    void SetInputLength(uint length)
    {
        _InputLength = length;
    }

    void SetInputPassword(string passwordChar)
    {
        _IsTextPassword = (passwordChar.length() == 1);
        _PasswordChar = passwordChar;
        _PasswordTime = 0;
    }

    void SetCarriage(bool enable)
    {
        _CarriagePos = (enable ? int(_Text.length()) : -1);
    }
};

class Button : Panel
{
    bool get_IsDisabled() final
    {
        return _IsDisabled;
    }
    bool get_IsSwitched() final
    {
        return _IsSwitched;
    }
    Sprite::Sprite get_PressedImage() final
    {
        return _PressedImage;
    }
    int get_PressedImageLayout() final
    {
        return _PressedImage != null ? _PressedImage.Layout : IMAGE_LAYOUT_NONE;
    }
    Sprite::Sprite get_HoverImage() final
    {
        return _HoverImage;
    }
    int get_HoverImageLayout() final
    {
        return _HoverImage != null ? _HoverImage.Layout : IMAGE_LAYOUT_NONE;
    }
    Sprite::Sprite get_DisabledImage() final
    {
        return _DisabledImage;
    }
    int get_DisabledImageLayout() final
    {
        return _DisabledImage != null ? _DisabledImage.Layout : IMAGE_LAYOUT_NONE;
    }

    bool _IsDisabled;
    bool _IsSwitched;
    Sprite::Sprite _PressedImage;
    Sprite::Sprite _HoverImage;
    Sprite::Sprite _DisabledImage;

    void _Construct() override
    {
        Panel::_Construct();

        _DeferredMousePressed = true;
    }

    void _Draw(bool callCallback) override
    {
        if (callCallback)
            _DrawCallback();

        if (!_IsDisabled) {
            // Pressed image
            bool isPressed = ((_IsPressed && _PressedButton == MouseButton::Left) || _IsSwitched);
            if (isPressed && _PressedImage != null)
                _DrawImage(_PressedImage);
            // Hover image
            else if (_IsHovered && _HoverImage != null)
                _DrawImage(_HoverImage);
            // Normal image
            else if (_BackgroundImage != null)
                _DrawImage(_BackgroundImage);
        }
        else {
            // Disabled image
            if (_DisabledImage != null)
                _DrawImage(_DisabledImage);
            // Normal image
            else if (_BackgroundImage != null)
                _DrawImage(_BackgroundImage);
        }

        Object::_Draw(false);

        if (callCallback)
            OnPostDraw();
    }

    void MouseClick(MouseButton button)
    {
        if (_IsDisabled)
            return;

        Panel::MouseClick(button);
    }

    void _MousePressed(MouseButton button)
    {
        if (_IsDisabled)
            return;

        Panel::_MousePressed(button);
    }

    void SetPressedImage(string imageName, int imageLayout = IMAGE_LAYOUT_NONE)
    {
        _SetImage(_PressedImage, imageName, imageLayout);
    }

    void SetPressedImage(hstring imageName, int imageLayout = IMAGE_LAYOUT_NONE)
    {
        _SetImage(_PressedImage, imageName, imageLayout);
    }

    void SetHoverImage(string imageName, int imageLayout = IMAGE_LAYOUT_NONE)
    {
        _SetImage(_HoverImage, imageName, imageLayout);
    }

    void SetHoverImage(hstring imageName, int imageLayout = IMAGE_LAYOUT_NONE)
    {
        _SetImage(_HoverImage, imageName, imageLayout);
    }

    void SetDisabledImage(string imageName, int imageLayout = IMAGE_LAYOUT_NONE)
    {
        _SetImage(_DisabledImage, imageName, imageLayout);
    }

    void SetDisabledImage(hstring imageName, int imageLayout = IMAGE_LAYOUT_NONE)
    {
        _SetImage(_DisabledImage, imageName, imageLayout);
    }

    void SetSwitch(bool enabled)
    {
        _IsSwitched = enabled;
    }

    void SetCondition(bool enabled)
    {
        _IsDisabled = !enabled;
    }
};

class CheckBox : Button
{
    bool get_IsChecked() final
    {
        return _IsSwitched;
    }

    // Callbacks
    void OnCheckedChanged()
    {
    }

    void MouseClick(MouseButton button)
    {
        if (_IsDisabled)
            return;

        if (button == MouseButton::Left)
            SetChecked(!_IsSwitched);

        Panel::MouseClick(button);
    }

    void SetChecked(bool checked)
    {
        if (_IsSwitched != checked) {
            _IsSwitched = checked;
            OnCheckedChanged();
        }
    }
};

class RadioButton : CheckBox
{
    void MouseClick(MouseButton button)
    {
        if (_IsDisabled || _IsSwitched)
            return;

        if (button == MouseButton::Left)
            SetChecked(true);

        Panel::MouseClick(button);
    }

    void SetChecked(bool checked) override
    {
        if (checked && _Parent != null) {
            for (uint i = 0; i < _Parent._Children.length(); i++) {
                RadioButton button = cast<RadioButton>(_Parent._Children[i]);
                if (button != null && button._IsSwitched) {
                    button._IsSwitched = false;
                    button.OnCheckedChanged();
                }
            }
        }

        if (_IsSwitched != checked) {
            _IsSwitched = checked;
            OnCheckedChanged();
        }
    }
};

class Screen : Panel
{
    int get_Index() final
    {
        return _Index;
    }
    bool get_IsMain() final
    {
        return IS_CLIENT_MAIN_SCREEN(_Index);
    }
    bool get_IsModal() final
    {
        return _IsModal;
    }
    bool get_IsMultiinstance() final
    {
        return _IsMultiinstance;
    }
    bool get_IsCloseOnMiss() final
    {
        return _IsCloseOnMiss;
    }
    CursorType[] get_AvailableCursors() final
    {
        return _AvailableCursors;
    }
    CursorType get_Cursor() final
    {
        return _Cursor;
    }
    bool get_IsCanMove() final
    {
        return _IsCanMove;
    }
    bool get_IsMoveIgnoreBorders() final
    {
        return _IsMoveIgnoreBorders;
    }
    bool get_IsOnTop() final
    {
        return _IsOnTop;
    }

    int _Index;
    bool _IsRegistered;
    bool _IsModal;
    bool _IsMultiinstance;
    bool _IsCloseOnMiss;
    CursorType[] _AvailableCursors;
    CursorType _Cursor;
    bool _IsCanMove;
    bool _IsMoveIgnoreBorders;
    bool _IsOnTop;

    // Workaround for input state accessing from shared code
    bool[] _InputKeyPressed;
    bool[] _InputMousePressed;

    void _Construct() override
    {
        _AvailableCursors = array<CursorType>();
        _InputKeyPressed = array<bool>();
        _InputMousePressed = array<bool>();

        Panel::_Construct();
    }

    void _FixClone() override
    {
        _AvailableCursors = array<CursorType>(_AvailableCursors);

        Panel::_FixClone();
    }

    void _Show(dict<string, string> params) override
    {
        // Make screen active
        _ActiveSelf = true;

        // Set default cursor
        _Cursor = (_AvailableCursors.length() > 0 ? AvailableCursors[0] : CursorType::Default);

        // Base behaviour
        Panel::_Show(params);
    }

    void _Hide() override
    {
        // Make screen active
        _ActiveSelf = false;

        // Base behaviour
        Panel::_Hide();
    }

    void _Appear() override
    {
        // On top
        _IsOnTop = true;

        // Set screen cursor
        Settings.Cursor = _Cursor;

        // Base behaviour
        Panel::_Appear();
    }

    void _Disappear() override
    {
        // Not on top more
        _IsOnTop = false;

        // Store cursor
        _Cursor = Settings.Cursor;
        if (_AvailableCursors.find(_Cursor) == -1)
            _Cursor = (_AvailableCursors.length() > 0 ? AvailableCursors[0] : CursorType::Default);

        // Base behaviour
        Panel::_Disappear();
    }

    void _GlobalMouseClick(MouseButton button) override
    {
        if (button == MouseButton::Right) {
            if (_AvailableCursors.length() > 0) {
                CursorType curCursor = Settings.Cursor;
                int curCursorIndex = _AvailableCursors.find(curCursor);
                if (curCursorIndex != -1) {
                    curCursorIndex++;
                    if (curCursorIndex >= int(_AvailableCursors.length()))
                        curCursorIndex = 0;
                    Settings.Cursor = _AvailableCursors[curCursorIndex];
                }
            }
        }
        else {
            Panel::_GlobalMouseClick(button);
        }
    }

    void _GlobalMouseMove() override
    {
        // Process moving
        if (_IsCanMove) {
            Object pressedObj = _FindPressed(this);
            if (pressedObj != null && pressedObj._PressedButton == MouseButton::Left && pressedObj._IsCatchable()) {
                int lastPosX = _AbsolutePosX;
                int lastPosY = _AbsolutePosY;
                int newPosX = _AbsolutePosX + (Settings.MouseX - pressedObj._PressedX);
                int newPosY = _AbsolutePosY + (Settings.MouseY - pressedObj._PressedY);
                pressedObj._PressedX = Settings.MouseX;
                pressedObj._PressedY = Settings.MouseY;

                // Check screen borders
                if (!_IsMoveIgnoreBorders) {
                    int parentAbsolutePosX = (_Parent != null ? _Parent._AbsolutePosX : 0);
                    int parentAbsolutePosY = (_Parent != null ? _Parent._AbsolutePosY : 0);
                    int parentWidth = (_Parent != null ? _Parent._Width : Settings.ScreenWidth);
                    int parentHeight = (_Parent != null ? _Parent._Height : Settings.ScreenHeight);
                    int px = newPosX;
                    int py = newPosY;
                    if (newPosX < parentAbsolutePosX)
                        newPosX = parentAbsolutePosX;
                    if (newPosY < parentAbsolutePosY)
                        newPosY = parentAbsolutePosY;
                    if (newPosX + _Width > parentWidth)
                        newPosX = parentWidth - _Width;
                    if (newPosY + _Height > parentHeight)
                        newPosY = parentHeight - _Height;
                    pressedObj._PressedX += newPosX - px;
                    pressedObj._PressedY += newPosY - py;
                }

                // Callback
                if (lastPosX != newPosX || lastPosY != newPosY) {
                    int deltaX = newPosX - lastPosX;
                    int deltaY = newPosY - lastPosY;
                    _Move(deltaX, deltaY, true, true);
                }
            }
        }

        Panel::_GlobalMouseMove();
    }

    Object _FindPressed(Object obj)
    {
        if (obj._IsPressed)
            return obj;
        for (uint i = 0; i < obj._Children.length(); i++) {
            Object pressedObj = _FindPressed(obj._Children[i]);
            if (pressedObj != null)
                return pressedObj;
        }
        return null;
    }

    // Options
    void SetModal(bool enabled)
    {
        _IsModal = enabled;
    }

    void SetMultiinstance(bool enabled)
    {
        _IsMultiinstance = enabled;
    }

    void SetCloseOnMiss(bool enabled)
    {
        _IsCloseOnMiss = enabled;
    }

    void SetAvailableCursors(CursorType[] cursors)
    {
        _AvailableCursors = cursors;
    }

    void SetCanMove(bool enabled, bool ignoreBorders)
    {
        _IsCanMove = enabled;
        _IsMoveIgnoreBorders = ignoreBorders;
    }
};

class Grid : Panel
{
    string get_CellPrototype() final
    {
        return _CellPrototype;
    }
    uint get_GridSize() final
    {
        return _GridSize;
    }
    int get_Columns() final
    {
        return _Columns;
    }
    int get_PaddingX() final
    {
        return _PaddingX;
    }
    int get_PaddingY() final
    {
        return _PaddingY;
    }
    Object[] get_Cells() final
    {
        return _Cells;
    }

    string _CellPrototype;
    uint _GridSize;
    int _Columns;
    int _PaddingX;
    int _PaddingY;
    Object[] _Cells;

    void _Construct() override
    {
        Panel::_Construct();

        _Cells = array<Object>();
    }

    void _FixClone() override
    {
        _Cells = array<Object>(_Cells);

        Panel::_FixClone();
    }

    void _Init() override
    {
        Panel::_Init();

        if (!_CellPrototype.isEmpty())
            SetCellPrototype(_CellPrototype);

        if (_GridSize > 0)
            ResizeGrid(_GridSize);
    }

    void ResizeGrid(uint size)
    {
        // Refresh grid size
        _GridSize = size;

        // Find cell prototype
        if (_CellPrototype.isEmpty())
            return;
        Object cellPrototype = (_CellPrototype[0] != "." ? Find(_CellPrototype) : Parent.Find(_CellPrototype.substr(1), false));
        if (cellPrototype == null)
            return;

        // Get cell index
        int childIndex = -1;
        if (cellPrototype._Parent is this)
            childIndex = cellPrototype._Parent._Children.findByRef(cellPrototype);

        // Remove current instances
        for (uint i = 0; i < _Children.length();) {
            if (_Cells.findByRef(_Children[i]) != -1) {
                _Children[i].SetActive(false);
                _SetCellIndex(_Children[i], null, uint(-1));
                _Children.removeAt(i);
            }
            else {
                i++;
            }
        }
        _Cells.clear();

        // Create new intsances
        cellPrototype._ActiveSelf = true;
        Object[] cellInstances = {};
        for (uint i = 0; i < _GridSize; i++) {
            Object cellInstance = cellPrototype._Clone(this);
            _Children.removeLast();
            _Children.insertAt(++childIndex, cellInstance);
            _Cells.insertLast(cellInstance);
            _SetCellIndex(cellInstance, this, cellInstances.length());
            cellInstances.insertLast(cellInstance);
        }
        cellPrototype._ActiveSelf = false;

        // Callbacks
        for (uint i = 0; i < cellInstances.length(); i++) {
            OnResizeGrid(cellInstances[i], i);
            _ResizeGrid(cellInstances[i], cellInstances[i], i);
        }

        // Init
        for (uint i = 0; i < cellInstances.length(); i++)
            cellInstances[i]._Init();

        // Move
        int col = 0, row = 0;
        int rowHeight = 0;
        int shiftX = -_HorizontalScroll;
        int shiftY = -_VerticalScroll;
        for (uint i = 0; i < cellInstances.length(); i++) {
            cellInstances[i]._Move(shiftX, shiftY, false, true);
            shiftX += cellInstances[i]._Width + _PaddingX;
            if (rowHeight < cellInstances[i]._Height + _PaddingY)
                rowHeight = cellInstances[i]._Height + _PaddingY;
            if (++col >= _Columns) {
                col = 0;
                row++;
                shiftX = 0;
                shiftY += rowHeight;
                rowHeight = 0;
            }
        }
        _ModifyScroll(0, 0);
    }

    void RefreshContentPositions()
    {
        if (_Cells.length() == 0)
            return;

        int col = 0, row = 0;
        int rowHeight = 0;
        int shiftX = -_HorizontalScroll;
        int shiftY = -_VerticalScroll;
        int baseX = _Cells[0]._BasePosX - _HorizontalScroll;
        int baseY = _Cells[0]._BasePosY - _VerticalScroll;
        for (uint i = 0; i < _Cells.length(); i++) {
            int ox = shiftX - _Cells[i]._BasePosX + baseX;
            int oy = shiftY - _Cells[i]._BasePosY + baseY;
            if (ox != 0 || oy != 0)
                _Cells[i]._Move(ox, oy, false, true);
            shiftX += _Cells[i]._Width + _PaddingX;
            if (rowHeight < _Cells[i]._Height + _PaddingY)
                rowHeight = _Cells[i]._Height + _PaddingY;
            if (++col >= _Columns) {
                col = 0;
                row++;
                shiftX = 0;
                shiftY += rowHeight;
                rowHeight = 0;
            }
        }
        _ModifyScroll(0, 0);
    }

    void _SetCellIndex(Object obj, Grid grid, uint cellIndex)
    {
        obj._Grid = grid;
        obj._CellIndex = cellIndex;

        for (uint i = 0; i < obj._Children.length(); i++)
            _SetCellIndex(obj._Children[i], grid, cellIndex);
    }

    void _ResizeGrid(Object obj, Object cell, uint cellIndex)
    {
        obj.OnResizeGrid(cell, cellIndex);

        for (uint i = 0; i < obj._Children.length(); i++)
            _ResizeGrid(obj._Children[i], cell, cellIndex);
    }

    void SetCellPrototype(string name)
    {
        _CellPrototype = name;
        if (!_CellPrototype.isEmpty()) {
            Object cellPrototype = (_CellPrototype[0] != "." ? Find(_CellPrototype) : Parent.Find(_CellPrototype.substr(1), false));
            if (cellPrototype != null)
                cellPrototype._ActiveSelf = false;
        }
    }

    void SetGridSize(uint size)
    {
        _GridSize = size;
    }

    void SetColumns(int length)
    {
        _Columns = length;
    }

    void SetPadding(int x, int y)
    {
        _PaddingX = x;
        _PaddingY = y;
    }
};

class MessageBox : Text
{
    string[] get_MessageTexts() final
    {
        return _MessageTexts;
    }
    int[] get_MessageTypes() final
    {
        return _MessageTypes;
    }
    string[] get_MessageTimes() final
    {
        return _MessageTimes;
    }
    bool[] get_DisplayedMessages() final
    {
        return _DisplayedMessages;
    }
    bool get_InvertMessages() final
    {
        return _InvertMessages;
    }

    string[] _MessageTexts;
    int[] _MessageTypes;
    string[] _MessageTimes;
    bool[] _DisplayedMessages;
    bool _InvertMessages;
    int _Scroll;
    int _MaxScroll;
    int _ScrollLines;
    Sprite::Sprite _ScrollUp;
    Sprite::Sprite _ScrollDown;
    bool _CursorHidden;

    void _Construct() override
    {
        Text::_Construct();

        _MessageTexts = array<string>();
        _MessageTypes = array<int>();
        _MessageTimes = array<string>();
        _DisplayedMessages = array<bool>(FOMB_ALL, true);

        _ScrollUp = Sprite::Sprite("MiniArrowUp.png");
        _ScrollDown = Sprite::Sprite("MiniArrowDown.png");
    }

    void _FixClone() override
    {
        _MessageTexts = array<string>(_MessageTexts);
        _MessageTypes = array<int>(_MessageTypes);
        _MessageTimes = array<string>(_MessageTimes);
        _DisplayedMessages = array<bool>(_DisplayedMessages);

        Text::_FixClone();
    }

    void _Show(dict<string, string> params) override
    {
        Text::_Show(params);

        _InvertMessages = Settings.MsgboxInvert;
        _GenerateText();
    }

    void _Draw(bool callCallback) override
    {
        if (!_InvertMessages)
            _TextFlags = FT_UPPER | FT_BOTTOM | FT_SKIPLINES_END(_ScrollLines);
        else
            _TextFlags = FT_SKIPLINES(_ScrollLines);

        Text::_Draw(callCallback);

        if (_IsHovered) {
            Sprite::Sprite spr = (Settings.MouseY < _AbsolutePosY + _Height / 2 ? _ScrollUp : _ScrollDown);
            spr.Draw(Settings.MouseX - spr.Width / 2, Settings.MouseY - spr.Height / 2);
        }
    }

    void _Remove() override
    {
        if (_CursorHidden) {
            _CursorHidden = false;
            Settings.HideCursor = false;
        }

        Text::_Remove();
    }

    void _Hover() override
    {
        Text::_Hover();

        if (!Settings.HideCursor) {
            _CursorHidden = true;
            Settings.HideCursor = true;
        }
    }

    void _Unhover() override
    {
        Text::_Unhover();

        if (_CursorHidden) {
            _CursorHidden = false;
            Settings.HideCursor = false;
        }
    }

    void _SizeChanged() override
    {
        _GenerateText();

        Text::_SizeChanged();
    }

    void _ActiveChanged() override
    {
        if (Active)
            _GenerateText();

        Text::_ActiveChanged();
    }

    void _MousePressed(MouseButton button) override
    {
        if (button == MouseButton::Left || button == MouseButton::WheelUp || button == MouseButton::WheelDown) {
            if (button == MouseButton::WheelUp || (button == MouseButton::Left && Settings.MouseY < _AbsolutePosY + _Height / 2)) {
                if (_InvertMessages && _Scroll > 0)
                    _Scroll--;
                if (!_InvertMessages && _Scroll < _MaxScroll)
                    _Scroll++;
            }
            else if (button == MouseButton::WheelDown || (button == MouseButton::Left && Settings.MouseY >= _AbsolutePosY + _Height / 2)) {
                if (_InvertMessages && _Scroll < _MaxScroll)
                    _Scroll++;
                if (!_InvertMessages && _Scroll > 0)
                    _Scroll--;
            }
            _GenerateText();
        }

        Text::_MousePressed(button);
    }

    void AddMessage(string text, int type = FOMB_GAME)
    {
        // Skip error messages
        if (type == FOMB_GAME && text == "error")
            return;

        // Set text
        string messageText;
        if (type >= FOMB_GAME && type <= FOMB_VIEW) {
            uint[] sayColors = {COLOR_DGREEN, COLOR_TEXT, COLOR_DRED, COLOR_DDGREEN};
            messageText = "|" + sayColors[type] + " " + EncodeUTF8(0x2022) + " |" + COLOR_TEXT + " " + text;
        }
        else {
            messageText = text;
        }
        _MessageTexts.insertLast(messageText);

        // Set type
        int messageType = type;
        _MessageTypes.insertLast(messageType);

        // Set time
        uint16 year = 0;
        uint16 month = 0;
        uint16 day = 0;
        uint16 dayOfWeek = 0;
        uint16 hour = 0;
        uint16 minute = 0;
        uint16 second = 0;
        uint16 milliseconds;
        GetTime(year, month, day, dayOfWeek, hour, minute, second, milliseconds);
        string messageTime = (hour <= 9 ? "0" : "") + hour + ":" + (minute <= 9 ? "0" : "") + minute + ":" + (second <= 9 ? "0" : "") + second + " ";
        _MessageTimes.insertLast(messageTime);

        // Generate mess box
        if (_DisplayedMessages[type]) {
            if (_Scroll > 0 && _IsHovered)
                _Scroll++;
            else
                _Scroll = 0;
        }
        _GenerateText();
    }

    void _GenerateText()
    {
        if (!Active)
            return;

        _Text = "";
        if (_MessageTexts.length() == 0)
            return;

        int tw = 0, th = 0;
        int maxLines = 0;
        GetTextInfo("", _Width, _Height, _TextFont, 0, tw, th, maxLines);
        if (maxLines <= 0) {
            _MaxScroll = 0;
            _ScrollLines = 0;
            return;
        }

        _ScrollLines = -1;
        int lines = 0;
        for (int i = _MessageTexts.length() - 1; i >= 0; i--) {
            string messageText = _MessageTexts[i];
            int messageType = _MessageTypes[i];
            string messageTime = _MessageTimes[i];

            // Skip if not need to display
            if (!_DisplayedMessages[messageType])
                continue;

            // Skip scrolled lines
            int curLines = lines;
            int skipLines = 0;
            GetTextInfo(messageText, _Width, 1000, _TextFont, 0, tw, th, skipLines);
            lines += skipLines;

            if (_ScrollLines < 0) {
                if (lines <= _Scroll)
                    continue;
                _ScrollLines = _Scroll - curLines;
            }

            if (curLines - _Scroll < maxLines) {
                // Add to message box
                if (_InvertMessages)
                    _Text += messageText + "\n";
                else
                    _Text = messageText + "\n" + _Text;
            }
            else {
                break;
            }
        }
        _MaxScroll = lines - maxLines;
        if (_ScrollLines < 0)
            _ScrollLines = 0;
    }

    bool _SetDisplayedMessage(int messageType, bool enable)
    {
        bool generateText = false;

        if (messageType != FOMB_ALL) {
            if (_DisplayedMessages[messageType] != enable) {
                _DisplayedMessages[messageType] = enable;
                generateText = true;
            }
        }
        else {
            for (uint i = 0; i < FOMB_ALL; i++) {
                if (_DisplayedMessages[messageType] != enable) {
                    _DisplayedMessages[messageType] = enable;
                    generateText = true;
                }
            }
        }

        return generateText;
    }

    void SetDisplayedMessages(int[] messageTypes)
    {
        bool generateText = false;
        bool displayAll = (messageTypes.find(FOMB_ALL) != -1);
        for (uint i = 0; i < _DisplayedMessages.length(); i++)
            if (_SetDisplayedMessage(i, displayAll || messageTypes.find(i) != -1))
                generateText = true;
        if (generateText)
            _GenerateText();
    }

    void ChangeDisplayedMessage(int messageType, bool enable)
    {
        if (_SetDisplayedMessage(messageType, enable))
            _GenerateText();
    }

    void SetInvertMessages(bool invert)
    {
        _InvertMessages = invert;
        _GenerateText();
    }

    void ClearMessages()
    {
        _MessageTexts.clear();
        _MessageTypes.clear();
        _MessageTimes.clear();
        _GenerateText();
    }
};

const string ConsoleDataPrefix = "console_";
class Console : TextInput
{
    bool get_DisableDeactivation() final
    {
        return _DisableDeactivation;
    }
    string get_HistoryStorageName() final
    {
        return _HistoryStorageName;
    }
    string[] get_History() final
    {
        return _History;
    }
    uint get_HistoryMaxLength() final
    {
        return _HistoryMaxLength;
    }

    bool _DisableDeactivation;
    string _HistoryStorageName;
    string _HistoryActualStorageName;
    string[] _History;
    uint _HistoryMaxLength;
    uint _HistoryCur;

    void _Construct() override
    {
        TextInput::_Construct();

        _History = array<string>();

        SetCarriage(true);
        _HistoryStorageName = "";
    }

    void _FixClone() override
    {
        _History = array<string>(_History);

        TextInput::_FixClone();
    }

    void _Show(dict<string, string> params) override
    {
        CurConsole = this;

        TextInput::_Show(params);
    }

    void _ActiveChanged() override
    {
        CustomCall("SetScreenKeyboard " + (Active ? "true" : "false"));

        TextInput::_ActiveChanged();
    }

    void Toggle()
    {
        if (!Active) {
            // Activate console
            Activate();
        }
        else if (_Text.length() == 0) {
            // Deactivate console
            if (!_DisableDeactivation)
                Deactivate();
        }
        else {
            // Send text
            SendText();
        }
    }

    void Activate()
    {
        // Activate console
        if (Active || !Parent.Active)
            return;

        // Load history
        string name = (GetChosen() != null ? GetChosen().Name : "");
        string actualStorageName = "";
        if (!_HistoryStorageName.isEmpty() && !name.isEmpty())
            actualStorageName = ConsoleDataPrefix + name + _HistoryStorageName;

        if (_HistoryActualStorageName != actualStorageName) {
            _History.clear();
            _HistoryActualStorageName = actualStorageName;
            if (_HistoryActualStorageName != "") {
                Serializator::Serializator data;
                if (data.LoadFromCache(_HistoryActualStorageName) > 0)
                    data.Get(_History);
            }
        }

        _HistoryCur = _History.length();

        // Raise callbacks
        SetActive(true);
    }

    void Deactivate()
    {
        // Deactivate console
        if (_ActiveSelf)
            SetActive(false);
    }

    void SendText()
    {
        if (!Active)
            return;

        // Modify history
        _History.insertLast(_Text);
        for (uint i = 0; i < _History.length() - 1;) {
            if (_History[i] == _History.last())
                _History.removeAt(i);
            else
                i++;
        }

        // Trim history length
        uint historyMaxLength = (_HistoryMaxLength != 0 ? _HistoryMaxLength : Settings.ConsoleHistorySize);
        while (_History.length() > historyMaxLength)
            _History.removeAt(0);
        _HistoryCur = _History.length();

        // Save history
        if (_HistoryActualStorageName != "") {
            Serializator::Serializator data;
            data.Set(_History);
            data.SaveToCache(_HistoryActualStorageName);
        }

        // Send
        bool[] keyPressed = Screen._InputKeyPressed;
        if (keyPressed[KeyCode::Lcontrol] || keyPressed[KeyCode::Rcontrol])
            CustomCall("ConsoleMessage\n/s" + _Text, "\n");
        else if (keyPressed[KeyCode::Lmenu] || keyPressed[KeyCode::Rmenu])
            CustomCall("ConsoleMessage\n/w" + _Text, "\n");
        else if (keyPressed[KeyCode::Lshift] || keyPressed[KeyCode::Rshift])
            CustomCall("ConsoleMessage\n/r" + _Text, "\n");
        else
            CustomCall("ConsoleMessage\n" + _Text, "\n");

        // Clear text
        _Text = "";
        _CarriagePos = 0;
    }

    void _ConsoleInput(KeyCode key, string text)
    {
        if (Active) {
            if (key == KeyCode::Up && _HistoryCur > 0) {
                _HistoryCur--;
                _Text = _History[_HistoryCur];
                _CarriagePos = _Text.length();
            }
            else if (key == KeyCode::Down) {
                if (_HistoryCur + 1 < _History.length()) {
                    _HistoryCur++;
                    _Text = _History[_HistoryCur];
                    _CarriagePos = _Text.length();
                }
                else {
                    _HistoryCur = _History.length();
                    _Text = "";
                    _CarriagePos = 0;
                }
            }
            else {
                TextInput::Input(key, text);
            }
        }

        if (key == KeyCode::Return || key == KeyCode::Numpadenter) {
            Toggle();
        }
    }

    void Input(KeyCode key, string text) override
    {
        Text::Input(key, text);
    }

    void _Draw(bool callCallback) override
    {
        if (callCallback)
            _DrawCallback();

        string text = Text;

        if (_CarriagePos < 0)
            _CarriagePos = 0;
        if (_CarriagePos > int(text.length()))
            _CarriagePos = text.length();

        text = text.substr(0, _CarriagePos) + (GetTick() % 800 < 400 ? "!" : ".") + text.substr(_CarriagePos);
        DrawText(text, _AbsolutePosX, _AbsolutePosY, _Width, _Height, _TextColor, _TextFont, _TextFlags);

        Object::_Draw(false);

        if (callCallback)
            OnPostDraw();
    }

    void SetDisableDeactivation(bool enable)
    {
        _DisableDeactivation = enable;
    }

    void SetHistoryStorage(string storageName)
    {
        // Set storage name
        _HistoryStorageName = storageName;
    }

    void SetHistoryMaxLength(uint length)
    {
        _HistoryMaxLength = length;
    }
};

class ItemView : Grid
{
    int get_UserData() final
    {
        return _UserData;
    }
    int get_UserDataExt() final
    {
        return _UserDataExt;
    }
    bool get_UseSorting() final
    {
        return _UseSorting;
    }

    int _UserData;
    int _UserDataExt;
    bool _UseSorting;
    Item[] _Items;
    uint _ItemsGridSize;

    void _Construct() override
    {
        Grid::_Construct();

        _Items = array<Item>();
    }

    void _FixClone() override
    {
        _Items = array<Item>(_Items);

        Grid::_FixClone();
    }

    // Callbacks
    Item[] OnGetItems()
    {
        return null;
    }
    int OnCheckItem(Item item)
    {
        return -1;
    }

    void _Init() override
    {
        _ItemsGridSize = _GridSize;

        Grid::_Init();
    }

    Item GetItem(uint cellIndex)
    {
        return _Items[cellIndex];
    }

    void Resort()
    {
        ResizeGrid(0);
    }

    void ResizeGrid(uint size) override
    {
        _Items.clear();

        Item[] items = OnGetItems();
        if (items == null)
            items = array<Item>();

        if (!_UseSorting) {
            _Items.resize(_ItemsGridSize);
            for (uint i = 0; i < items.length(); i++) {
                int itemIndex = OnCheckItem(items[i]);
                if (itemIndex >= 0 && itemIndex < int(_Items.length()))
                    _Items[itemIndex] = items[i];
            }
        }
        else {
            int[] sortValues = {};
            for (uint i = 0; i < items.length(); i++) {
                int sortValue = OnCheckItem(items[i]);
                if (sortValue >= 0) {
                    bool added = false;
                    for (uint j = 0; j < _Items.length(); j++) {
                        if (sortValues[j] > sortValue) {
                            _Items.insertAt(j, items[i]);
                            sortValues.insertAt(j, sortValue);
                            added = true;
                            break;
                        }
                    }
                    if (!added) {
                        _Items.insertLast(items[i]);
                        sortValues.insertLast(sortValue);
                    }
                }
            }
        }

        Grid::ResizeGrid(_Items.length());
    }

    void SetUserData(int data)
    {
        _UserData = data;
    }

    void SetUserDataExt(int data)
    {
        _UserDataExt = data;
    }

    void SetUseSorting(bool enable)
    {
        _UseSorting = enable;
    }
};

// Implementation

dict<int, CreateScreenFunc> ScreenCreators = {};

Screen[] Screens = {};
Screen CursorScreen;

Object FocusedObject;
Object PressedObject;
uint PressedObjectRepeatTime;
Object LastPressedObject;
Object HoveredObject;

DragAndDropHandler[] DragAndDropHandlers = {};

IDropMenu DropMenu;

Console CurConsole;

//
// Public API
//

void RegisterScreen(int screenIndex, CreateScreenFunc screenFunc)
{
    UnregisterScreen(screenIndex);

    if (screenIndex == CLIENT_SCREEN_NONE)
        return;

    @ScreenCreators[screenIndex] = screenFunc;

    // Precache
    Screen screen = CreateScreen(screenIndex);
    if (screen.IsMultiinstance) {
        screen._Remove();
        Screens.removeAt(Screens.findByRef(screen));
    }
}

Screen GetScreen(int screenIndex)
{
    Screen lastMultiinstanceScreen = null;
    for (int i = int(Screens.length()) - 1; i >= 0; i--) {
        Screen screen = Screens[i];
        if (screen.Index == screenIndex) {
            if (!screen.IsMultiinstance)
                return screen;
            else
                lastMultiinstanceScreen = screen;
        }
    }
    return lastMultiinstanceScreen;
}

Screen GetActiveMainScreen()
{
    for (uint i = 0; i < Screens.length(); i++)
        if (Screens[i].ActiveSelf && Screens[i].IsMain)
            return Screens[i];
    return null; // Should not be reach this point
}

Screen GetActiveScreen()
{
    for (int i = int(Screens.length()) - 1; i >= 0; i--)
        if (Screens[i].ActiveSelf)
            return Screens[i];
    return null; // Should not be reach this point
}

void GetActiveScreens(Screen[] result)
{
    for (uint i = 0; i < Screens.length(); i++)
        if (Screens[i].ActiveSelf)
            result.insertLast(Screens[i]);
}

Object GetFocusedObject()
{
    if (FocusedObject != null && !FocusedObject.Active) {
        auto obj = FocusedObject;
        FocusedObject = null;
        obj._Unfocus();
    }
    return FocusedObject;
}

void SetFocusedObject(Object obj)
{
    if (FocusedObject != null) {
        auto fobj = FocusedObject;
        FocusedObject = null;
        fobj._Unfocus();
    }

    if (obj != null && obj.Active) {
        FocusedObject = obj;
        FocusedObject._Focus();
    }
}

Object GetPressedObject()
{
    if (PressedObject != null && !PressedObject.Active) {
        auto obj = PressedObject;
        PressedObject = null;
        obj._MouseUp(true);
        LastPressedObject = null;
    }
    return PressedObject;
}

Object GetLastPressedObject()
{
    if (LastPressedObject != null && !LastPressedObject.Active)
        LastPressedObject = null;
    return LastPressedObject;
}

Object GetDraggedObject()
{
    if (PressedObject != null && !PressedObject.Active) {
        auto obj = PressedObject;
        PressedObject = null;
        obj._MouseUp(true);
    }
    return PressedObject != null && PressedObject._IsDragged ? PressedObject : null;
}

Object GetHoveredObject()
{
    if (HoveredObject != null && !HoveredObject.Active) {
        auto obj = HoveredObject;
        HoveredObject = null;
        obj._Unhover();
    }
    return HoveredObject;
}

void NextTextInput()
{
    Screen screen = GetActiveScreen();
    if (screen == null)
        return;

    GetFocusedObject(); // Refresh state
    TextInput curTextInput = cast<TextInput>(FocusedObject);
    FindNextTextInputSkipObj = curTextInput;
    TextInput textInput = FindNextTextInput(screen);
    FindNextTextInputSkipObj = null;
    if (textInput == null && curTextInput != null)
        textInput = FindNextTextInput(screen);

    if (textInput != null && textInput !is curTextInput) {
        if (FocusedObject != null) {
            auto obj = FocusedObject;
            FocusedObject = null;
            obj._Unfocus();
        }
        FocusedObject = textInput;
        FocusedObject._Focus();
    }
}

Object FindNextTextInputSkipObj = null;
TextInput FindNextTextInput(Object obj)
{
    if (FindNextTextInputSkipObj == null) {
        TextInput textInput = cast<TextInput>(obj);
        if (textInput != null)
            return textInput;
    }
    else if (obj is FindNextTextInputSkipObj) {
        FindNextTextInputSkipObj = null;
    }

    for (uint i = 0; i < obj._Children.length(); i++) {
        if (obj._Children[i]._ActiveSelf) {
            TextInput textInput = FindNextTextInput(obj._Children[i]);
            if (textInput != null)
                return textInput;
        }
    }
    return null;
}

MessageBox[] CollectMessageBoxes()
{
    MessageBox[] messageBoxes = {};
    for (int i = int(Screens.length()) - 1; i >= 0; i--)
        CollectMessageBoxes(Screens[i], messageBoxes);
    return messageBoxes;
}

void CollectMessageBoxes(Object obj, MessageBox[] messageBoxes)
{
    MessageBox mb = cast<MessageBox>(obj);
    if (mb != null)
        messageBoxes.insertLast(mb);

    for (uint i = 0; i < obj._Children.length(); i++)
        CollectMessageBoxes(obj._Children[i], messageBoxes);
}

bool IsConsoleActive()
{
    for (int i = int(Screens.length()) - 1; i >= 0; i--)
        if (IsConsoleActive(Screens[i]))
            return true;
    return false;
}

bool IsConsoleActive(Object obj)
{
    if (!obj.ActiveSelf)
        return false;

    Console console = cast<Console>(obj);
    if (console != null)
        return true;

    for (uint i = 0; i < obj._Children.length(); i++)
        if (IsConsoleActive(obj._Children[i]))
            return true;

    return false;
}

void AddDragAndDropHandler(DragAndDropHandler handler)
{
    DragAndDropHandlers.insertLast(handler);
}

void SetDropMenu(IDropMenu dropMenu)
{
    DropMenu = dropMenu;
}

bool CheckHit(int x, int y)
{
    for (uint i = 0; i < Screens.length(); i++)
        if (Screens[i].ActiveSelf && Screens[i].FindHit(x, y) != null)
            return true;
    return false;
}

//
// Engine callbacks
//

void EngineCallback_Start()
{
    // Register custom screens
    GuiScreens::InitializeScreens();

    // Register hardcoded screens
    CreateHardcodedScreen(CLIENT_MAIN_SCREEN_LOGIN);
    CreateHardcodedScreen(CLIENT_MAIN_SCREEN_GAME);
    CreateHardcodedScreen(CLIENT_MAIN_SCREEN_GLOBAL_MAP);
    CreateHardcodedScreen(CLIENT_MAIN_SCREEN_WAIT);
    CreateHardcodedScreen(CLIENT_SCREEN_DIALOG);
    CreateHardcodedScreen(CLIENT_SCREEN_DIALOGBOX);
    CreateHardcodedScreen(CLIENT_SCREEN_TOWN_VIEW);
}

void EngineCallback_ShowScreen(int screenIndex, dict<string, string> params)
{
    Settings.ScrollMouseUp = false;
    Settings.ScrollMouseRight = false;
    Settings.ScrollMouseDown = false;
    Settings.ScrollMouseLeft = false;
    Settings.ScrollKeybUp = false;
    Settings.ScrollKeybRight = false;
    Settings.ScrollKeybDown = false;
    Settings.ScrollKeybLeft = false;

    // Manage multiinstance
    for (int i = int(Screens.length()) - 1; i >= 0; i--) {
        // Find instance
        Screen screen = Screens[i];
        if (screen.Index != screenIndex)
            continue;

        // Move to top created instance
        if (!screen.IsMultiinstance) {
            ShowHideScreen(screen, params, true);
            return;
        }
    }

    // Create new instance
    Screen screen = CreateScreen(screenIndex);
    ShowHideScreen(screen, params, true);
}

void EngineCallback_HideScreen(int screenIndex)
{
    for (int i = int(Screens.length()) - 1; i >= 0; i--) {
        // Find instance
        Screen screen = Screens[i];
        if (!screen.ActiveSelf || screen.Index != screenIndex)
            continue;

        // Hide
        ShowHideScreen(screen, null, false);

        // Hide only one screen per call
        break;
    }
}

void EngineCallback_Draw()
{
    for (uint i = 0; i < Screens.length(); i++) {
        Screen screen = Screens[i];
        if (screen.ActiveSelf) {
            if (screen.Index == CLIENT_MAIN_SCREEN_WAIT)
                CustomCall("DrawWait");
            screen._Draw(true);
        }
    }
}

void EngineCallback_DrawCursor()
{
    // Dragged object
    Object draggedObject = GetDraggedObject();
    if (draggedObject != null) {
        int x = 0, y = 0, w = 0, h = 0;
        draggedObject.GetWholeSize(x, y, w, h);
        draggedObject.Draw(Settings.MouseX - w / 2, Settings.MouseY - h / 2);
        return;
    }

    // Drop menu
    if (DropMenu != null)
        DropMenu.Draw();

    // Cursor
    if (CursorScreen != null)
        CursorScreen._Draw(true);
}

void EngineCallback_MouseDown(MouseButton button)
{
    // Unfocus current object
    if (button == MouseButton::Left && FocusedObject != null) {
        auto obj = FocusedObject;
        FocusedObject = null;
        obj._Unfocus();
    }

    // Release mouse from current object
    if (PressedObject != null) {
        auto obj = PressedObject;
        PressedObject = null;
        obj._MouseUp(true);
    }

    // Process mouse down
    Screen screen = GetActiveScreen();
    if (screen == null)
        return;

    // Global callback
    screen._GlobalMouseDown(button);

    // Drop menu
    if (DropMenu != null)
        DropMenu.MouseDown(button);

    // Check hit on current screen
    Object hitObj = screen.FindMouseHit();
    if (hitObj != null) {
        // Handle pressed object
        PressedObject = hitObj;
        PressedObjectRepeatTime = GetTick() + 500;
        LastPressedObject = hitObj;
        PressedObject._MouseDown(button);

        // Handle focused object
        if (button == MouseButton::Left) {
            FocusedObject = hitObj;
            FocusedObject._Focus();
        }
        return;
    }

    // Close on miss
    if (button == MouseButton::Left && screen.IsCloseOnMiss) {
        ShowHideScreen(screen, null, false);
        return;
    }

    // Switch to another screen
    if (button == MouseButton::Left && !screen.IsModal) {
        int screenIndex = Screens.findByRef(screen);
        for (int i = screenIndex - 1; i >= 0; i--) {
            Screen nextScreen = Screens[i];
            if (!nextScreen.ActiveSelf)
                continue;

            if (nextScreen.IsModal || nextScreen.FindMouseHit() != null) {
                // Show screen to top and click on it
                ShowHideScreen(nextScreen, null, true, nextScreen);
                EngineCallback_MouseDown(button);
                return;
            }
        }
    }
}

void EngineCallback_MouseUp(MouseButton button)
{
    // Global handler
    Screen screen = GetActiveScreen();
    if (screen != null)
        screen._GlobalMouseUp(button);

    // Release mouse from current object
    GetPressedObject(); // Refresh state
    if (PressedObject != null && button == PressedObject._PressedButton) {
        Object obj = PressedObject;
        PressedObject = null;
        bool isDragged = obj._IsDragged;
        obj._MouseUp(false);

        if (obj.IsMouseHit()) {
            if (screen != null)
                screen._GlobalMouseClick(button);
            obj.MouseClick(button);
        }

        if (isDragged && screen != null) {
            Object target = screen.FindMouseHit();
            for (uint i = 0; i < DragAndDropHandlers.length(); i++)
                if (DragAndDropHandlers[i](obj, target))
                    break;
        }
    }

    // Drop menu
    if (DropMenu != null)
        DropMenu.MouseUp(button);
}

void EngineCallback_MouseMove(int offsetX, int offsetY)
{
    bool realMove = (offsetX != 0 || offsetY != 0);

    // Drop menu
    if (DropMenu != null) {
        if (DropMenu.PreMouseMove(offsetX, offsetY))
            return;
    }

    // Move mouse for active screen
    Screen screen = GetActiveScreen();
    Object hoveredObj;
    if (screen != null) {
        if (realMove)
            screen._GlobalMouseMove();
        hoveredObj = screen.FindMouseHit();
        if (realMove && hoveredObj != null)
            hoveredObj._MouseMove();
    }

    // Change hover object
    GetHoveredObject(); // Refresh state
    if (HoveredObject !is hoveredObj) {
        if (HoveredObject != null) {
            auto obj = HoveredObject;
            HoveredObject = null;
            obj._Unhover();
        }
        HoveredObject = hoveredObj;
        if (HoveredObject != null)
            HoveredObject._Hover();
    }

    // Drop menu
    if (DropMenu != null)
        DropMenu.PostMouseMove(offsetX, offsetY);
}

void EngineCallback_KeyDown(KeyCode key, string text)
{
    // Global input handler
    for (int i = int(Screens.length()) - 1; i >= 0; i--)
        if (Screens[i]._ActiveSelf)
            Screens[i]._GlobalInput(key, text);

    // Console input
    if (CurConsole != null)
        CurConsole._ConsoleInput(key, text);

    // Focused object input
    if (CurConsole == null || !CurConsole.Active) {
        Screen screen = GetActiveScreen();
        GetFocusedObject(); // Refresh state
        if (FocusedObject != null && FocusedObject !is screen)
            FocusedObject.Input(key, text);
    }
}

void EngineCallback_KeyUp(KeyCode key)
{
    // ...
}

void EngineCallback_InputLost()
{
    if (HoveredObject != null) {
        auto obj = HoveredObject;
        HoveredObject = null;
        obj._Unhover();
    }
    if (FocusedObject != null) {
        auto obj = FocusedObject;
        FocusedObject = null;
        obj._Unfocus();
    }
    if (PressedObject != null) {
        auto obj = PressedObject;
        PressedObject = null;
        obj._MouseUp(true);
    }

    if (DropMenu != null)
        DropMenu.InputLost();
}

void EngineCallback_Loop()
{
    if (Settings.WaitPing || Settings.IsConnecting || Settings.IsUpdating)
        Input::ReleaseMouse();

    GetPressedObject(); // Refresh state
    if (PressedObject != null) {
        uint tick = GetTick();
        if (tick >= PressedObjectRepeatTime && PressedObject.IsMouseHit()) {
            PressedObjectRepeatTime = tick + 40;
            Screen screen = GetActiveScreen();
            if (screen != null)
                screen._GlobalMousePressed(PressedObject._PressedButton);
            PressedObject._MousePressed(PressedObject._PressedButton);
        }
    }

    EngineCallback_MouseMove(0, 0);

    // Drop menu
    if (DropMenu != null)
        DropMenu.Loop();
}

void EngineCallback_GetActiveScreens(int[] result)
{
    for (uint i = 0; i < Screens.length(); i++)
        if (Screens[i].ActiveSelf)
            result.insertLast(Screens[i].Index);
}

void EngineCallback_ItemChanged(bool onMap)
{
    if (!onMap) {
        ItemView[] itemViews = {};
        CollectItemView(itemViews);
        for (uint i = 0; i < itemViews.length(); i++)
            itemViews[i].Resort();
    }
}

void CollectItemView(ItemView[] itemViews)
{
    for (int i = int(Screens.length()) - 1; i >= 0; i--)
        CollectItemView(Screens[i], itemViews);
}

void CollectItemView(Object obj, ItemView[] itemViews)
{
    ItemView itemView = cast<ItemView>(obj);
    if (itemView != null)
        itemViews.insertLast(itemView);

    for (uint i = 0; i < obj._Children.length(); i++)
        CollectItemView(obj._Children[i], itemViews);
}

//
// Custom callbacks
//

void Callback_OnResolutionChanged()
{
    for (uint i = 0; i < Screens.length(); i++)
        Screens[i]._Reload(false, true);
}

void Callback_OnLanguageChanged()
{
    for (uint i = 0; i < Screens.length(); i++)
        Screens[i]._Reload(true, true);
}

//
// Internal
//

Screen CreateEmptyScreen()
{
    Screen screen = Screen();
    screen.Init(null);
    return screen;
}

void CreateHardcodedScreen(int screenIndex)
{
    if (GetScreen(screenIndex) == null) {
        RegisterScreen(screenIndex, CreateEmptyScreen);
        CreateScreen(screenIndex);
    }
}

Screen CreateScreen(int screenIndex)
{
    CreateScreenFunc screenFunc = ScreenCreators[screenIndex];
    Screen screen = screenFunc();
    Assert(screen != null, screenIndex);
    screen._Index = screenIndex;
    screen._ActiveSelf = false;
    screen._IsRegistered = true;
    screen._InputKeyPressed = Input::GetKeyPressed();
    screen._InputMousePressed = Input::GetMousePressed();

    if (screenIndex != CLIENT_SCREEN_CURSOR)
        Screens.insertLast(screen);
    else
        CursorScreen = screen;

    screen._Init();
    return screen;
}

void UnregisterScreen(int screenIndex)
{
    for (int i = int(Screens.length()) - 1; i >= 0; i--) {
        Screen screen = Screens[i];
        if (screen.Index == screenIndex) {
            if (screen.ActiveSelf)
                ShowHideScreen(screen, null, false);
            if (!screen.IsMultiinstance) {
                screen._Remove();
                Screens.removeAt(i);
            }
            screen._IsRegistered = false;
        }
    }
}

void ShowHideScreen(Screen screen, dict<string, string> params, bool show, Screen appearScreen = null)
{
    // Clean hovered/focused/pressed objects
    if (HoveredObject != null) {
        auto obj = HoveredObject;
        HoveredObject = null;
        obj._Unhover();
    }
    if (FocusedObject != null) {
        auto obj = FocusedObject;
        FocusedObject = null;
        obj._Unfocus();
    }
    if (PressedObject != null) {
        auto obj = PressedObject;
        PressedObject = null;
        obj._MouseUp(true);
    }

    if (show) {
        // Hide active screen
        Screen activeScreen = GetActiveScreen();
        if (activeScreen != null && activeScreen !is screen)
            activeScreen._Disappear();

        // Focus and hover new elements
        FocusedObject = FindNextTextInput(screen);
        if (FocusedObject != null)
            FocusedObject._Focus();
        HoveredObject = screen.FindMouseHit();
        if (HoveredObject != null)
            HoveredObject._Hover();

        // Move to top
        if (Screens.last() !is screen) {
            Screens.removeAt(Screens.findByRef(screen));
            Screens.insertLast(screen);
        }

        // Callback
        if (!screen._ActiveSelf)
            screen.SetActive(true);
        if (appearScreen == null)
            screen._Show(params);
        screen._Appear();
    }
    else {
        // Ignore redundant hide
        if (!screen._ActiveSelf)
            return;

        // Callbacks
        screen._Disappear();
        screen._Hide();
        screen.SetActive(false);

        // Remove multiinstance
        if (screen.IsMultiinstance) {
            screen._Remove();
            Screens.removeAt(Screens.findByRef(screen));
        }

        // Appear active screen
        if (appearScreen == null)
            appearScreen = GetActiveScreen();
        if (appearScreen != null) {
            // Move to top
            if (Screens.last() !is appearScreen) {
                Screens.removeAt(Screens.findByRef(appearScreen));
                Screens.insertLast(appearScreen);
            }

            appearScreen._Appear();
        }
    }
}

uint GetScreenCount(int screenIndex)
{
    uint count = 0;
    for (int i = int(Screens.length()) - 1; i >= 0; i--)
        if (Screens[i].Index == screenIndex)
            count++;
    return count;
}
